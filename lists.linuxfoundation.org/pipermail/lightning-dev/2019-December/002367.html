<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20%5BDRAFT%5D%20BOLT%2013%28%3F%29%3A%20WatchTower%20protocol&In-Reply-To=%3CCAEYHFxUQhF_Q4BOTNH%2BzPNP%2BYjmGmUYU3K2PCsKD7hwH%2BaiF0g%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002357.html">
   <LINK REL="Next"  HREF="002368.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol</H1>
    <B>Sergi Delgado Segura</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20%5BDRAFT%5D%20BOLT%2013%28%3F%29%3A%20WatchTower%20protocol&In-Reply-To=%3CCAEYHFxUQhF_Q4BOTNH%2BzPNP%2BYjmGmUYU3K2PCsKD7hwH%2BaiF0g%40mail.gmail.com%3E"
       TITLE="[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol">sergi.delgado.s at gmail.com
       </A><BR>
    <I>Thu Dec  5 16:21:10 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="002357.html">[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol
</A></li>
        <LI>Next message: <A HREF="002368.html">[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2367">[ date ]</a>
              <a href="thread.html#2367">[ thread ]</a>
              <a href="subject.html#2367">[ subject ]</a>
              <a href="author.html#2367">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hey Antoine, thanks for the feedback.

On Fri, Nov 29, 2019 at 6:43 AM Antoine Riard &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">antoine.riard at gmail.com</A>&gt;
wrote:

&gt;<i> Thanks for working on this, a bunch of interesting ideas!
</I>&gt;<i>
</I>&gt;<i> I think it could be noted in the motivation, that's having an interoperable
</I>&gt;<i> watchtower protocol is really cool, because every watchtower you add is
</I>&gt;<i> a liveness reliability increase (modulo privacy loss), specially if these
</I>&gt;<i> watchtowers are from different implementations in case of a vuln affecting
</I>&gt;<i> breach
</I>&gt;<i> monitoring code of your LN node.
</I>&gt;<i>
</I>&gt;<i> Some generic remarks, you should define another TCP port than the LN one
</I>&gt;<i> of 9735
</I>&gt;<i> because this is client-server relationship and you want to avoid leak of
</I>&gt;<i> p2p
</I>&gt;<i> messages to your watchtower.
</I>&gt;<i>
</I>
We considered that, but we're unsure about whether that would be the best
way to go, or it would be better to add additional messages at a p2p level.
Also there's the option of piggybacking information using the current
messages, which is the approach followed by lnd at the moment IIRC.


&gt;<i> Messages should also use the TLV format, will remove a lot *_len field and
</I>&gt;<i> each
</I>&gt;<i> QoS could be a tlv_record in `appointment`.
</I>&gt;<i>
</I>
I'll look into the TLV format and redesign it accordingly.


&gt;<i>
</I>&gt;<i> For the init protocol, I was considering the following scheme.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>                         init
</I>&gt;<i>                 ----------------------&gt;
</I>&gt;<i>
</I>&gt;<i>                         version
</I>&gt;<i>                 &lt;----------------------
</I>&gt;<i>        Alice                                 Bob
</I>&gt;<i>                     payment protocol
</I>&gt;<i>                 -----------------------&gt;
</I>&gt;<i>                          ...
</I>&gt;<i>
</I>&gt;<i>                     appointment hiring
</I>&gt;<i>                 -----------------------&gt;
</I>&gt;<i>                          ...
</I>&gt;<i>
</I>&gt;<i>                     appointment firing
</I>&gt;<i>                 -----------------------&gt;
</I>&gt;<i>
</I>&gt;<i> The `init` message would contain a method to establish a secure connection
</I>&gt;<i> between client and server. Watchtower shouldn't learn LN pubkey of client
</I>&gt;<i> as it may be a conflict of interest and be leveraged to build more
</I>&gt;<i> sophisticated
</I>&gt;<i> attacks. So client should implement identity contingement properly and use
</I>&gt;<i> the `init` message to start a Noise session or something like BIP324.
</I>&gt;<i>
</I>
We were thinking on not having any way of linking appointments from the the
same user. The only &quot;identity&quot; we were considering is the `auth_token`,
that can easily be used as a nonce. It's also possible to use the same for
multiple appointments, depending on the user.


&gt;<i>
</I>&gt;<i> After secure connection establishement, `version` would be the reply with
</I>&gt;<i> a features field, wider than only QoS like also the payment protocol
</I>&gt;<i> supported,
</I>&gt;<i> and maybe an invoice for the payment protocol preferred. In a future,
</I>&gt;<i> features may
</I>&gt;<i> extend beyond channel watching, like timing out client HTLC or
</I>&gt;<i> synchronization
</I>&gt;<i> server for multi-party channels...
</I>&gt;<i>
</I>
Agreed, we were thinking on something similar. The peer discovery has not
been defined yet, but it seems reasonable for the tower to advertise the
services it offers on the first message. An init approach as you proposed
seems to have the problem of how the user finds the tower. On the other
hand, if there's a peers discovery (either trough DNS seed or something
different) the init/version steps can be simplified.


&gt;<i>
</I>&gt;<i> Client would then execute the one or multiple steps of the payment
</I>&gt;<i> protocol.
</I>&gt;<i> This one may be complex, i.e include parameters negotiation like update
</I>&gt;<i> rate-limiting, feerate for encrypted blob, storage throttling after time
</I>&gt;<i> X, ...
</I>&gt;<i> I do think this kind of parameters belong there compare to
</I>&gt;<i> `appointment_hiring`,
</I>&gt;<i> as they may cover watching operations of one or more channels and secondly
</I>&gt;<i> they
</I>&gt;<i> are DoS protections, and payment scheme and DoS are going to be really tied
</I>&gt;<i> in watchtowers protocol.
</I>&gt;<i>
</I>
Agreed, the user should provide proof of payment in the
`appointment_hiring` but all the steps to accomplish that should be done
beforehand.


&gt;<i>
</I>&gt;<i> Then `appointment_hiring` with QoS and their parameters, is there reasons
</I>&gt;<i> for
</I>&gt;<i> not having them being stable for the lifetime of client-server interaction
</I>&gt;<i> ?
</I>&gt;<i>
</I>
Well, as I was saying we were thinking on avoiding having any link between
different appointments from the same user, therefore specifying it
appointment-wise.


&gt;<i>
</I>&gt;<i> Finally, some `appointment_firing` to let the client cut its subscription
</I>&gt;<i> and
</I>&gt;<i> authorize the server to clean storage.
</I>&gt;<i>
</I>
That's the reasoning behind the `end_block`, allowing the tower to clean
the data after a certain time.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; * `start_block` is further than one block behind the current chain tip.
</I>&gt;<i> &gt; * `start_block` is further than one block ahead the current chain tip.
</I>&gt;<i>
</I>&gt;<i> Is a 3 block window enough if the client is a mobile which a lot of
</I>&gt;<i> latency and weak
</I>&gt;<i> processing compare to a watchtower's competitive full-node ? I think it's
</I>&gt;<i> only
</I>&gt;<i> a block issuance edge case but maybe could be easier if client set
</I>&gt;<i> start_block to
</I>&gt;<i> current_seen_block_height+6 and server would reject if height already
</I>&gt;<i> past..
</I>&gt;<i>
</I>
The 3 block window was defined as a way for the tower to learn whether the
client was up to date or not. Also a malicious user may try to hire a tower
to look for something that's already resolved in the blockchain making the
tower do &quot;the heavy lifting&quot; of parsing information from arbitrarily old
blocks. 3 is also an arbitrary number, and can be extended. It would also
work for the tower to advertise it's tip and for the user to agree on that.


&gt;<i>
</I>&gt;<i> &gt; minimum_viable_transaction_size and maximum_viable_transaction_size
</I>&gt;<i> refer to the minimum/maximum size required to create a valid transaction.
</I>&gt;<i>
</I>&gt;<i> Couldn't these limits be implictly MAX_STANDARD_TX_WEIGHT and
</I>&gt;<i> MAX_STANDARD_TX_NONWITNESS_SIZE, current mempool policy limits ?
</I>&gt;<i>
</I>
True, but those are not consensus rules (AFAIK at least) so they are
subjective to change. I think some sanity checks from the tower side may be
worthy. It's also worth noting that this checks only prevent naive attacks,
since properly formatted blobs would pass the them.


&gt;<i>
</I>&gt;<i> Also, nothing is specified on disconnection/reconnection, you want to be
</I>&gt;<i> sure than
</I>&gt;<i> watchtower as ACK every justice tx sent as every one of them maybe
</I>&gt;<i> critical. A client
</I>&gt;<i> doesn't want to assume is channel is covered and finally not due to its
</I>&gt;<i> network
</I>&gt;<i> connection being rotten.
</I>&gt;<i>
</I>

It may be worth having some kind of ack, but it's also worth mentioning
that the user may be offline (since that's one of the main use cases of the
towers), so sending and ack may be useful but we shouldn't rely on the
assumption that the user will receive it.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; * MUST set `dispute_delta` to the CLTV value specified in the
</I>&gt;<i> &gt; `commitment_transaction`.
</I>&gt;<i>
</I>&gt;<i> What's a dispute delta ? You mean the justice-CSV locktime encumbering
</I>&gt;<i> outputs ?
</I>&gt;<i> Given this one is fixed at channel opening, it should be fixed also for
</I>&gt;<i> the channel
</I>&gt;<i> hiring lifetime. And server should announce a min_dispute_delta at QoS
</I>&gt;<i> `accountability`
</I>&gt;<i> announcement.
</I>&gt;<i>
</I>
Yes, that's what we meant. Sorry for not using the proper naming. Same
reasoning as before, in our proposal the tower has no clue whether two
appointments are from the same channel or not. I guess it's worth
discussing if this makes sense or if it's better to switch to an approach
where they can be linked even if it leaks some information about the
channel usage.


&gt;<i>
</I>&gt;<i> &gt; * MUST set `transaction_size` to the size of the serialized
</I>&gt;<i> &gt; `justice_transaction`, in bytes.
</I>&gt;<i>
</I>&gt;<i> I would remove the transaction size, given that all outputs are
</I>&gt;<i> standardized in LN, that would
</I>&gt;<i> be a leak on how much payment traffic is going through the client without
</I>&gt;<i> any channel breach.
</I>&gt;<i>
</I>&gt;<i> &gt; * MUST set `transaction_fee` to the fee set in the `justice_transaction`,
</I>&gt;<i> &gt; in satoshis.
</I>&gt;<i>
</I>&gt;<i> Generally, the idea to provide justice tx with pre-signed fees to a
</I>&gt;<i> watchtower and expect
</I>&gt;<i> this one to do is job reliably somewhere in the future seem a weak
</I>&gt;<i> assumption... Every watchtower
</I>&gt;<i> following this protocol should handle dynamic fees, that's should be a
</I>&gt;<i> basic service not even
</I>&gt;<i> a QoS. It may through CPFP (but won't be reliable until package relay( or
</I>&gt;<i> RBF'ing the justice
</I>&gt;<i> tx through usage of SIGHASH_ANYONECANPAY, no need interactivity with the
</I>&gt;<i> user at broadcast,
</I>&gt;<i> but you may need a populated input mempool.
</I>&gt;<i>
</I>
The original idea of both the fee and size was to allow the tower to decide
whether or not it would be able to relay the transaction (specially in the
case where the end_time is close to the current time). Thinking about it
trough though it seems a pretty weak assumption, since in most of the cases
the tower may not be able to predict future fees. I do like the idea of
the SIGHASH_ANYONECANPAY approach to allow the tower to bump the fees. I'll
need to think more about it.

&gt;<i> While a customer can always fake this values, it should break ToS between
</I>&gt;<i> the client and the
</I>&gt;<i> server and, therefore, release the WatchTower of any liability
</I>&gt;<i>
</I>&gt;<i> I can imagine with machine-readable proofs a bot fetching proofs servers,
</I>&gt;<i> verifying them
</I>&gt;<i> on the blockchain and scoring in consequence watchtowers. Good marks could
</I>&gt;<i> be done via
</I>&gt;<i> some tagging of justice tx (like setting nLocktime in the past to some
</I>&gt;<i> value). You would
</I>&gt;<i> negotiate a different tag for everyone of your watchtower. Removing
</I>&gt;<i> feerate from the equation
</I>&gt;<i> would simplify scoring as now you don't have to guess if mempool was
</I>&gt;<i> congestionned or not for
</I>&gt;<i> the client-provided fee.
</I>&gt;<i>
</I>&gt;<i> &gt; On top of that, the onchain bounty allows a network-wise DoS attack for
</I>&gt;<i> free.
</I>&gt;<i>
</I>&gt;<i> A good point of the onchain bounty is the user doesn't pay for inefficient
</I>&gt;<i> watchtower or
</I>&gt;<i> suppleous watchtower. But seems hard to implement DoS-wise and at the same
</I>&gt;<i> time keep the
</I>&gt;<i> requirement of pseudonymous clients. Nevertheless a note maybe said on a
</I>&gt;<i> LN node implementing
</I>&gt;<i> some kind of anyone-can-spend on top of its txn and let the vigilant crowd
</I>&gt;<i> bid with fees
</I>&gt;<i> and confirm your punishment, that's would be the &quot;watchtowerless
</I>&gt;<i> watchtower protocol&quot; :p
</I>&gt;<i>
</I>
Yep, we agree is not a straightforward problem to solve, so open to ideas!


&gt;<i>
</I>&gt;<i> &gt; That would break appointment unlinkability but would ease the data
</I>&gt;<i> &gt; management for the tower.
</I>&gt;<i>
</I>&gt;<i> Unlinkability should be far higher in the BOLT design decisions, I think
</I>&gt;<i> people may don't
</I>&gt;<i> care about unlinkability in case of all watchtowers servers are running
</I>&gt;<i> under same
</I>&gt;<i> organization but they are interested by some building blocks of this spec
</I>&gt;<i> like tracking ACK
</I>&gt;<i> or fees management delegation. So we may have multiple formats for the
</I>&gt;<i> transaction
</I>&gt;<i> locator/encryption and one of them being the empty one ?
</I>&gt;<i>
</I>
I don't follow you here :sweet_smile:


&gt;<i>
</I>&gt;<i> &gt; The `customer_signature` could be optional if the client does not care
</I>&gt;<i> &gt; that much about the worst case. Dicuss whether that makes sense.
</I>&gt;<i>
</I>&gt;<i> I think you're right it can be skipped as client has provided a signed
</I>&gt;<i> justice
</I>&gt;<i> tx as an implicit commitment ?
</I>&gt;<i>
</I>&gt;<i> Okay that's a lot and it's really IMO, I do think that's important to have
</I>&gt;<i> a flexible protocol
</I>&gt;<i> with a lot of room for further privacy/efficiency/services upgrades and
</I>&gt;<i> circumvent non-seen now
</I>&gt;<i> complexity. If watchtowers are economically/sociably viable it maybe a
</I>&gt;<i> layer of its own!
</I>&gt;<i>
</I>
Agreed, that's one of the reasons why some of the bits haven't been defined
yet, since we're unsure what the community thinks about embedding this
within the protocol or having something on top of it.


&gt;<i>
</I>&gt;<i> Le mer. 27 nov. 2019 &#224; 15:20, Sergi Delgado Segura &lt;
</I>&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">sergi.delgado.s at gmail.com</A>&gt; a &#233;crit :
</I>&gt;<i>
</I>&gt;&gt;<i> Hi all,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Patrick McCorry and I have been working on putting together a BOLT draft
</I>&gt;&gt;<i> for WatchTowers. So far we've seen a couple of implementation of
</I>&gt;&gt;<i> WatchTowers in the wild (lnd and Electrum) based on Tadge's Monitor
</I>&gt;&gt;<i> approach and we are also working on our own one. While all are similar,
</I>&gt;&gt;<i> they differ in some points that may make then non interoperable, so it felt
</I>&gt;&gt;<i> right time to put some effort and try to standardise this. We've borrowed
</I>&gt;&gt;<i> ideas from all implementations as well as from the original approach and
</I>&gt;&gt;<i> added some additional bits to extended with different quality of service.
</I>&gt;&gt;<i> The draft is still rough on the edges and have several open discussion
</I>&gt;&gt;<i> topics at the very end (#FIXME section).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Best,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # WatchTower protocol specification (BOLT DRAFT)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Overview
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All off-chain protocols assume the user remains online and synchronised
</I>&gt;&gt;<i> with the network. To alleviate this assumption, customers can hire a third
</I>&gt;&gt;<i> party watching service (a.k.a WatchTower) to watch the blockchain and
</I>&gt;&gt;<i> respond to channel breaches on their behalf.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> At a high level, the client sends an encrypted justice transaction
</I>&gt;&gt;<i> alongside a transaction locator to the WatchTower. Both the encryption key
</I>&gt;&gt;<i> and the transaction locator are derived from the breach transaction id,
</I>&gt;&gt;<i> meaning that the WatchTower will be able to decrypt the justice transaction
</I>&gt;&gt;<i> only after the corresponding breach is seen on the blockchain. Therefore,
</I>&gt;&gt;<i> the WatchTower does not learn any information about the client's channel
</I>&gt;&gt;<i> unless there is a channel breach (channel-privacy).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Due to replace-by-revocation Lightning channels, the client should send
</I>&gt;&gt;<i> data to the WatchTower for every new update in the channel, otherwise the
</I>&gt;&gt;<i> WatchTower may not be able to respond to specific breaches.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Finally, optional QoS can be offered by the WatchTower to provide
</I>&gt;&gt;<i> stronger guarantees to the client, such as a signed receipt for every new
</I>&gt;&gt;<i> job. The rationale for the receipt is to build an _accountable_ WatchTower
</I>&gt;&gt;<i> as the customer can later use it as publicly verifiable evidence if the
</I>&gt;&gt;<i> WatchTower fails to protect them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The scope of this document includes:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - A protocol for client/server communication.
</I>&gt;&gt;<i> - How to build appointments for the WatchTower, including key/locator
</I>&gt;&gt;<i> derivation and data encryption.
</I>&gt;&gt;<i> - A format for the signed receipt.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The scope of this bolt does not include:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  - A payment protocol between the customer and WatchTower.
</I>&gt;&gt;<i>  - WatchTower server discovery.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For the rest of this document we will refer to the WatchTower as server,
</I>&gt;&gt;<i> and the user/Lightning node as client.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Table of Contents
</I>&gt;&gt;<i> * [WatchTower discovery](#watchtower-discovery)
</I>&gt;&gt;<i> * [WatchTower services](#watchtower-discovery)
</I>&gt;&gt;<i> * [Basic Service](#basic-service)
</I>&gt;&gt;<i> * [Quality of Service](#quality-of-service)
</I>&gt;&gt;<i> * [Sending and receiving
</I>&gt;&gt;<i> appointments](#sending-and-receiving-appointments)
</I>&gt;&gt;<i>   * [The `appointment` message](#the-appointment-message)
</I>&gt;&gt;<i>   * [The `appointment_accepted`
</I>&gt;&gt;<i> message](#the-appointment_accepted-message)
</I>&gt;&gt;<i>   * [The `appointment_rejected`
</I>&gt;&gt;<i> message](#the-appointment_rejected-message)
</I>&gt;&gt;<i> * [Quality of Service data](#quality-of-service-data)
</I>&gt;&gt;<i> * [`accountability`](#accountability)
</I>&gt;&gt;<i> * [Transaction Locator and Encryption
</I>&gt;&gt;<i> Key](#transaction-locator-and-encryption-key)
</I>&gt;&gt;<i> * [Encryption Algorithms and
</I>&gt;&gt;<i> Parameters](#encryption-algorithms-and-parameters)
</I>&gt;&gt;<i> * [Payment Modes](#payment-modes)
</I>&gt;&gt;<i> * [No compression of justice
</I>&gt;&gt;<i> transaction](#no-compression-of-justice-transaction)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## WatchTower discovery
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We have not defined how a client can find a list of servers to hire yet.
</I>&gt;&gt;<i> We assume the client has found a server and the server is offering a
</I>&gt;&gt;<i> watching service. The service can either be the basic service or an
</I>&gt;&gt;<i> accountable quality of service. To deal with pre-payments (when necessary),
</I>&gt;&gt;<i> the client may have an authentication token that the server can verify when
</I>&gt;&gt;<i> accepting the job (e.g. a blinded token).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## WatchTower services
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### Basic Service
</I>&gt;&gt;<i> The customer can hire the WatchTower to watch for breaches on the
</I>&gt;&gt;<i> blockchain and relay a justice transaction on their behalf. The customer
</I>&gt;&gt;<i> receives an acknowledgement when the WatchTower has accepted the job, but
</I>&gt;&gt;<i> the hiring protocol does not guarantee the transaction inclusion.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### Quality of Service
</I>&gt;&gt;<i> Quality of Service (`qos`) builds on top of the basic service provided by
</I>&gt;&gt;<i> a tower and it's optionally provided. Different kinds of QoS can be offered
</I>&gt;&gt;<i> by the tower.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For now we are defining a single type of `qos`: `accountability`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### `accountability`
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A WatchTower provides a signed receipt to the customer. This is
</I>&gt;&gt;<i> considered reputational accountability as the customer has publicly
</I>&gt;&gt;<i> verifiable cryptographic evidence the WatchTower was hired. The receipt can
</I>&gt;&gt;<i> be used to prove the WatchTower did not relay the justice transaction on
</I>&gt;&gt;<i> their behalf and/or request a refund.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Sending and receiving appointments
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Once the client is aware of the services provided by the server, the
</I>&gt;&gt;<i> former can start sending appointments to the latter.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +-------+                                    +-------+
</I>&gt;&gt;<i> |   A   |--(1)---      appointment      ----&gt;|   B   |
</I>&gt;&gt;<i> |       |&lt;-(2)---   accepted/rejected   -----|       |
</I>&gt;&gt;<i> +-------+                                    +-------+
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - where node A is 'client' and node B is 'server'
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### The `appointment` message
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This message contains all the information regarding the appointment that
</I>&gt;&gt;<i> the client wants to arrange with the server.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. type: ? (`appointment`)
</I>&gt;&gt;<i> 2. data:
</I>&gt;&gt;<i>    * [`16*byte`:`locator`]
</I>&gt;&gt;<i>    * [`u64 `:`start_block`]
</I>&gt;&gt;<i>    * [`u64 `:`end_block`]
</I>&gt;&gt;<i>    * [`u16`: `encrypted_blob_len`
</I>&gt;&gt;<i>    * [`encrypted_blob_len*byte`:`encrypted_blob`]
</I>&gt;&gt;<i>    * [`u16`:`cipher`]
</I>&gt;&gt;<i>    * [`u16`: `auth_token_len`]
</I>&gt;&gt;<i>    * [`auth_token_len*byte`: `auth_token`]
</I>&gt;&gt;<i>    * [`u16`: `qos_len`]
</I>&gt;&gt;<i>    * [`qos_len*byte`: `qos_data`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Requirements
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The client:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST set `locator` as specified in [Transaction Locator and Encryption
</I>&gt;&gt;<i> Key](#transaction-locator-and-encryption-key).
</I>&gt;&gt;<i> * MUST set `start_block` to the current chain tip height.
</I>&gt;&gt;<i> * MUST set `end_block` to the block height at which he requests the
</I>&gt;&gt;<i> server to stop watching for breaches.
</I>&gt;&gt;<i> * MUST set `encrypted_blob` to the encryption of the
</I>&gt;&gt;<i> `justice_transaction` as specified in [Transaction Locator and Encryption
</I>&gt;&gt;<i> Key](#transaction-locator-and-encryption-key).
</I>&gt;&gt;<i> * MUST set `cipher` to the cipher used to create the `encrypted_blob`.
</I>&gt;&gt;<i> * MAY send an empty `auth_token` field.
</I>&gt;&gt;<i> * MUST set `auth_token_len` to the length of `auth_token`.
</I>&gt;&gt;<i> * MAY send an empty `qos_data` field.
</I>&gt;&gt;<i> * if `qos_data` is not empty:
</I>&gt;&gt;<i> *  MUST set `qos_data` according to [Quality of Service
</I>&gt;&gt;<i> data](#quality-of-service-data).
</I>&gt;&gt;<i> * MUST set `qos_len` equal to the length of `qos_data`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST reject the appointment if:
</I>&gt;&gt;<i> * Authentication is required and `auth_token` is not provided.
</I>&gt;&gt;<i> * Authentication is required and `auth_token` is invalid.
</I>&gt;&gt;<i> * `locator` is not a `16-byte` value.
</I>&gt;&gt;<i> * `start_block` is further than one block behind the current chain tip.
</I>&gt;&gt;<i> * `start_block` is further than one block ahead the current chain tip.
</I>&gt;&gt;<i> * `encrypted_blob` has unreasonable size.
</I>&gt;&gt;<i> * `cipher` is not among the ones he implements.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * SHOULD reject the appointment if`end_block` is too far away in the
</I>&gt;&gt;<i> future.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST:
</I>&gt;&gt;<i> * truncate the remainder of the package to `qos_len`.
</I>&gt;&gt;<i> * process `qos_data` according to [Quality of Service
</I>&gt;&gt;<i> data](#quality-of-service-data) if `qos_len` is not 0.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MAY accept the appointment otherwise.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Rationale
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We define appointment as the way that the WatchTower is hired / requested
</I>&gt;&gt;<i> by a client to do it's watching services.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> WatchTowers may offer their services for free (`altruistic`) or they may
</I>&gt;&gt;<i> require a payment when accepting the job (`non-altruistic`). We have
</I>&gt;&gt;<i> defined `auth_token` as an authentication mechanism between the client and
</I>&gt;&gt;<i> server, so the client can prove they are entitled to the service. The
</I>&gt;&gt;<i> tokens are not required to be linked to any kind of identity (e.g. blinded
</I>&gt;&gt;<i> tokens), but their sole purpose is to confirm the client has already paid
</I>&gt;&gt;<i> for the service.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The transaction `locator` can be deterministically computed by both the
</I>&gt;&gt;<i> client and the server. Locators of wrong size are therefore invalid.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `start_block` can be either one block ahead or behind the tower tip due
</I>&gt;&gt;<i> to network delays. A tower must not accept appointments arbitrarily ahead
</I>&gt;&gt;<i> or behind the current tip since it could increase DoS vectors. A
</I>&gt;&gt;<i> `start_block` long behind would force the tower to rescan block data for
</I>&gt;&gt;<i> those appointments instead of watching block by block. On the other hand, a
</I>&gt;&gt;<i> `start_time` long ahead would imply storing information way before it being
</I>&gt;&gt;<i> needed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Regarding the `end_block`, too far away is a subjective concept. The
</I>&gt;&gt;<i> further away a tower accepts appointment ends, the higher the potential
</I>&gt;&gt;<i> storage requirements may be, and the easier, and cheaper, it my be to
</I>&gt;&gt;<i> perform DoS.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The `encrypted_blob` should have been encrypted using `cipher`. Block
</I>&gt;&gt;<i> ciphers have a size multiple of the block length, which depends on the key
</I>&gt;&gt;<i> size. Therefore the `encrypted_blob` have to be at least as big as:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `cipher_block_size * ceil(minimum_viable_transaction_size /
</I>&gt;&gt;<i> cipher_block_size)`
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> and at most as big as:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `cipher_block_size * ceil(maximum_viable_transaction_size /
</I>&gt;&gt;<i> cipher_block_size`)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `minimum_viable_transaction_size` and `maximum_viable_transaction_size`
</I>&gt;&gt;<i> refer to the minimum/maximum size required to create a valid transaction.
</I>&gt;&gt;<i> Accepting `encrypted_blob` outside those boundaries will increase DoS
</I>&gt;&gt;<i> attacks on the server.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The client should have learn about the `ciphers` implemented by the
</I>&gt;&gt;<i> WatchTower and the `qos` that the tower is offering during the peer
</I>&gt;&gt;<i> discovery.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A tower must not accept appointments using a cipher it does not
</I>&gt;&gt;<i> implement, otherwise the decryption of the `encrypted_blob` will not be
</I>&gt;&gt;<i> possible.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `qos` is optional and can include multiple services.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### The `appointment_accepted` message
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This message contains information about the acceptance of an appointment
</I>&gt;&gt;<i> by the WatchTower.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. type: ? (`appointment_accepted `)
</I>&gt;&gt;<i> 2. data:
</I>&gt;&gt;<i>    * [`16*byte `:`locator`]
</I>&gt;&gt;<i>    * [`u16`: `qos_len`]
</I>&gt;&gt;<i> * [`qos_len*byte`: `qos_data`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST receive `appointment` before sending an `appointment_accepted`
</I>&gt;&gt;<i> message.
</I>&gt;&gt;<i> * MUST set the `locator` to match the one received in `appointment`.
</I>&gt;&gt;<i> * if `qos_data` was requested in `appointment`:
</I>&gt;&gt;<i> *  MUST set `qos_data` according to [Quality of Service
</I>&gt;&gt;<i> data](#quality-of-service-data).
</I>&gt;&gt;<i> * MUST set `qos_len` equal to the length of `qos_data`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The client:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST fail the connection  if `locator` does not match any of locators
</I>&gt;&gt;<i> the previously sent to the server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * if `qos` was requested in `appointment`:
</I>&gt;&gt;<i> * MUST fail the connection if `qos_len` is 0.
</I>&gt;&gt;<i> * MUST process `qos_data` according to [Quality of Service
</I>&gt;&gt;<i> data](#quality-of-service-data).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### The `appointment_rejected` message
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This message contains information about the rejection of an appointment
</I>&gt;&gt;<i> by the WatchTower.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. type: ? (`appointment_rejected `)
</I>&gt;&gt;<i> 2. data:
</I>&gt;&gt;<i>    * [`16*byte `:`locator`]
</I>&gt;&gt;<i>    * [`u16`: `rcode`]
</I>&gt;&gt;<i>    * [`u16`: `reason_len`
</I>&gt;&gt;<i>    * [`reason_len*byte`: `reason`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST receive `appointment` before sending an `appointment_rejected`
</I>&gt;&gt;<i> message.
</I>&gt;&gt;<i> * MUST set the `locator` to match the one received in `appointment`.
</I>&gt;&gt;<i> * MUST set `rcode` to the rejection code.
</I>&gt;&gt;<i> * MAY set and empty `reason` field.
</I>&gt;&gt;<i> * MUST set `reason_len` to length of `reason`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Rationale
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The `appointment_rejected` message follows the approach taken by the
</I>&gt;&gt;<i> `error` message defined in [BOLT#1](
</I>&gt;&gt;<i> <A HREF="https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message">https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message</A>):
</I>&gt;&gt;<i> error codes are mandatory, whereas reasons are optional and implementation
</I>&gt;&gt;<i> dependant.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Quality of Service data
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `qos_data` is a list where each field specifies they type and associated
</I>&gt;&gt;<i> data of the offered/requested `qos`. The format is defined as follows:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * [`u16`: `qos_type`]
</I>&gt;&gt;<i> * [`u16`: `data_len`]
</I>&gt;&gt;<i> * [`data_len*byte`: `data`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So far, only `accountability` is defined.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ### `accountability`
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The accountability `qos` defines a pair `qos_data` blobs, associated to a
</I>&gt;&gt;<i> pair of messages: The first one is `customer_evidence` and it is provided
</I>&gt;&gt;<i> by the `client` in the `appointment` message. The second one is
</I>&gt;&gt;<i> `tower_evidence`, and is provided by the WatchTower in the
</I>&gt;&gt;<i> `appointment_accepted` message.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### `customer_evidence`
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The format for the `customer_evidence` is defined as follows:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. type: ? (`customer_evidence`)
</I>&gt;&gt;<i> 2. data:
</I>&gt;&gt;<i> * [`u64 `:`dispute_delta`]
</I>&gt;&gt;<i> * [`u64`: `transaction_size`]
</I>&gt;&gt;<i> * [`u64`: `transaction_fee`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If `accountability` is being requested, the client:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST set `dispute_delta` to the CLTV value specified in the
</I>&gt;&gt;<i> `commitment_transaction`.
</I>&gt;&gt;<i> * MUST set `transaction_size` to the size of the serialized
</I>&gt;&gt;<i> `justice_transaction`, in bytes.
</I>&gt;&gt;<i> * MUST set `transaction_fee` to the fee set in the `justice_transaction`,
</I>&gt;&gt;<i> in satoshis.
</I>&gt;&gt;<i> * MUST set the `customer_signature_algorithm` to one of the signature
</I>&gt;&gt;<i> algorithms supported by the tower.
</I>&gt;&gt;<i> * MUST set `customer_signature` to the signature of the appointment using
</I>&gt;&gt;<i> `op_customer_signature_algorithm`.
</I>&gt;&gt;<i> * MUST set `customer_public_key` to the public key that matches the
</I>&gt;&gt;<i> private key used to create `op_customer_signature`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If `accountability` is being offered, the server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST compute the `customer_signature` verification using
</I>&gt;&gt;<i> `customer_public_key`.
</I>&gt;&gt;<i> * SHOULD compute the `fee_rate` set in the `justice_tx` using
</I>&gt;&gt;<i> `transaction_size` and `transaction_fee`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST reject the appointment if:
</I>&gt;&gt;<i> * Any of the fields is missing.
</I>&gt;&gt;<i> * `transaction_size` is unreasonable.
</I>&gt;&gt;<i> * `customer_signature_algorithm` does not match any of the supported
</I>&gt;&gt;<i> signing algorithms.
</I>&gt;&gt;<i> * `customer_signature` cannot be verified using `customer_public_key`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * SHOULD reject the appointment if:
</I>&gt;&gt;<i> * `dispute_delta` is too small.
</I>&gt;&gt;<i> * `fee_rate` is too low.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If `accountability` is NOT being offered:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * The server MUST reject the appointment.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Otherwise:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * The server SHOULD accept the appointment.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Rationale
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The concept of too small for `dispute_delta` is subjective. The
</I>&gt;&gt;<i> `dispute_delta` defines the time (in blocks) that the tower has in order to
</I>&gt;&gt;<i> respond after a breach is seen. The smaller the value, the more the server
</I>&gt;&gt;<i> risks to fail the appointment.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> `transaction_size` and `transaction_fee` help the WatchTower to decide on
</I>&gt;&gt;<i> the likelihood of an appointment being fulfilled. Appointments with
</I>&gt;&gt;<i> `fee_rate` too low may be rejected by the WatchTower. While a customer can
</I>&gt;&gt;<i> always fake this values, it should break ToS between the client and the
</I>&gt;&gt;<i> server and, therefore, release the WatchTower of any liability.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> By accepting the request, the tower is offering a reputationally
</I>&gt;&gt;<i> accountable watching service. If `accountability` is not offered, then the
</I>&gt;&gt;<i> tower will not accept appointments requesting for it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As well, the WatchTower must check the transaction details before
</I>&gt;&gt;<i> deciding whether it will accept it. If the decrypted justice transaction
</I>&gt;&gt;<i> does not satisfy the job details (e.g. too low fee), then the tower is not
</I>&gt;&gt;<i> obliged to fulfil the appointment.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### `tower_evidence`
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The format for the `tower_evidence` is defined as follows:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. type: ? (`tower_evidence`)
</I>&gt;&gt;<i> 2. data:
</I>&gt;&gt;<i> * [`u16 `:`receipt_len`]
</I>&gt;&gt;<i> * [`receipt_len*byte `: `receipt`]
</I>&gt;&gt;<i> * [`u16`: `wt_signature_algorithm`]
</I>&gt;&gt;<i> * [`u16`: `wt_signature_len`
</I>&gt;&gt;<i> * [`wt_signature_len*byte`: `wt_signature`]
</I>&gt;&gt;<i> * [`u16`: `wt_public_key_len`]
</I>&gt;&gt;<i> * [`wt_public_key_len*byte`: `wt_public_key`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST set `receipt` to a receipt built according to
</I>&gt;&gt;<i> [Receipt-Format](#receipt-format).
</I>&gt;&gt;<i> * MUST set `wt_signature_algorithm` to one of the signature algorithms he
</I>&gt;&gt;<i> has announced.
</I>&gt;&gt;<i> * MUST set `wt_signature` to the signature of the appointment using
</I>&gt;&gt;<i> `wt_signature_algorithm`.
</I>&gt;&gt;<i> * MUST set `wt_public_key` to the public key that matches the private key
</I>&gt;&gt;<i> used to create `wt_signature`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The client:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST compute the `wt_signature` verification using `wt_public_key`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * MUST fail the connection if:
</I>&gt;&gt;<i> * Any of the fields is missing.
</I>&gt;&gt;<i> * `receipt` does not matches the format specified at
</I>&gt;&gt;<i> [Receipt-Format](#receipt-format)
</I>&gt;&gt;<i> * `receipt` fields do not match the ones sent in the `appointment`
</I>&gt;&gt;<i> message.
</I>&gt;&gt;<i> * `wt_signature_algorithm` does not match any of the ones offered by the
</I>&gt;&gt;<i> server.
</I>&gt;&gt;<i> * `wt_signature` cannot be verified using `wt_public_key`.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Receipt Format
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server MUST create the receipt containing the following information:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> txlocator
</I>&gt;&gt;<i> start_block
</I>&gt;&gt;<i> end_block
</I>&gt;&gt;<i> dispute_delta
</I>&gt;&gt;<i> encrypted_blob
</I>&gt;&gt;<i> transaction_size
</I>&gt;&gt;<i> transaction_fee
</I>&gt;&gt;<i> cipher
</I>&gt;&gt;<i> customer_signature
</I>&gt;&gt;<i> wt_public_key
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Rationale
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We assume the client has a well-known public key for the WatchTower.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The receipt contains, mainly, the information provided by the user. The
</I>&gt;&gt;<i> WatchTower will need to sign the receipt to provide evidence of agreement.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The `customer_signature` is included in the receipt to link both the
</I>&gt;&gt;<i> client request and the server response. Otherwise, the tower could sign a
</I>&gt;&gt;<i> receipt with different data that the one sent by the user, and the user
</I>&gt;&gt;<i> would have no way to prove whether that's true or not. By signing the
</I>&gt;&gt;<i> customer signature there the tower creates evidence of what the user sent,
</I>&gt;&gt;<i> since the tower cannot forge the client's signature.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> #### Receipt serialization and signature
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [FIXME: TBD]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Transaction Locator and Encryption Key
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Implementations MUST compute the `locator`, `encryption_key` and
</I>&gt;&gt;<i> `encryption_iv` from the commitment transaction as defined below:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - `locator`: first half of the commitment transaction id
</I>&gt;&gt;<i> (`commitment_txid(0,16]`)
</I>&gt;&gt;<i> - `master_key`: Hash of the second half of the commitment transaction id
</I>&gt;&gt;<i> (`SHA256(commitment_txid(16,32])`)
</I>&gt;&gt;<i> - `encryption_key`: first half of the master key (`master_key(0,16]`)
</I>&gt;&gt;<i> - `encryption_iv`: second half of the master key (`master_key(16,32]`)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server relies on both the encryption key and iv to decrypt the
</I>&gt;&gt;<i> justice transaction. Furthermore, the transaction locator helps the
</I>&gt;&gt;<i> WatchTower identify a breach transaction on the blockchain.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Encryption Algorithms and Parameters
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All clients and servers MUST use one of the following encryption
</I>&gt;&gt;<i> algorithms:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - ChaCha20 (<A HREF="https://tools.ietf.org/html/rfc7539">https://tools.ietf.org/html/rfc7539</A>)
</I>&gt;&gt;<i> - AES-GCM-256 (<A HREF="https://tools.ietf.org/html/rfc5288">https://tools.ietf.org/html/rfc5288</A>)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sample code (python) for the client to prepare the `encrypted_blob`:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> from hashlib import sha256
</I>&gt;&gt;<i> from binascii import hexlify
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> def encrypt(justice_tx, commitment_txid):
</I>&gt;&gt;<i>    # master_key = SHA256(commitment_txid(16, 32])
</I>&gt;&gt;<i>    master_key = sha256(commitment_txid[16:]).digest()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    # The 16 MSB of the master key will serve as the AES-GCM-256 secret
</I>&gt;&gt;<i> key. The 16 LSB will serve as the IV.
</I>&gt;&gt;<i>    sk = master_key[:16]
</I>&gt;&gt;<i>    nonce = master_key[16:]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    # Encrypt the data
</I>&gt;&gt;<i>    aesgcm = AESGCM(sk)
</I>&gt;&gt;<i>    encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx,
</I>&gt;&gt;<i> associated_data=None)
</I>&gt;&gt;<i>    encrypted_blob = hexlify(encrypted_blob).decode()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    return encrypted_blob
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## Payment modes
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Although this BOLT does not enforce any specific payment method to be
</I>&gt;&gt;<i> adopted, it is worth mentioning the three most common ones:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> **On-chain bounty**. An additional output is created in the justice
</I>&gt;&gt;<i> transaction that will reward the WatchTower.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> **Micropayments**. A small payment is sent to the WatchTower for every
</I>&gt;&gt;<i> new job (e.g. over the lightning network)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> **Subscription**. WatchTower is periodically rewarded / paid for their
</I>&gt;&gt;<i> service to the customer. (e.g. over the lightning network or fiat
</I>&gt;&gt;<i> subscription).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Both micropayments and subscriptions are favourable for a WatchTower. The
</I>&gt;&gt;<i> on-chain bounty approach is not ideal for a watching network, it lets the
</I>&gt;&gt;<i> customer hire many WatchTowers (O(N) storage for each tower) and only one
</I>&gt;&gt;<i> WatchTower will be rewarded upon collecting the bounty. On top of that, the
</I>&gt;&gt;<i> onchain bounty allows a network-wise DoS attack for free.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## No compression of justice transaction
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The storage requirements for a WatchTower can be reduced (linearly) by
</I>&gt;&gt;<i> implementing [shachain](
</I>&gt;&gt;<i> <A HREF="https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt">https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt</A>),
</I>&gt;&gt;<i> therefore storing the parts required to build the transaction and the
</I>&gt;&gt;<i> corresponding signing key instead of the full transaction. For now, we have
</I>&gt;&gt;<i> decided to keep the hiring protocol simple. Storage is relatively cheap and
</I>&gt;&gt;<i> we can revisit this standard if it becomes a problem.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ## FIXMES
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - Define a proper tower discovery.
</I>&gt;&gt;<i> - Define authentication mechanism (macaroons maybe?).
</I>&gt;&gt;<i> - None of the message types have been defined (they have been left with
</I>&gt;&gt;<i> ?).
</I>&gt;&gt;<i> - Define receipt serialization format.
</I>&gt;&gt;<i> - `qos_type` can be defined by ranges, in the same way that error
</I>&gt;&gt;<i> messages are. In that way a range of values can belong to a specific `qos`.
</I>&gt;&gt;<i> - Define an optional way of doing batch appointments / appointments in
</I>&gt;&gt;<i> bulk? That would break appointment unlinkability but would ease the data
</I>&gt;&gt;<i> management for the tower.
</I>&gt;&gt;<i> - The `customer_signature` could be optional if the client does not care
</I>&gt;&gt;<i> that much about the worst case. Dicuss whether that makes sense.
</I>&gt;&gt;<i> - Discuss whether to extend it with shachain.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The document can also be found here:
</I>&gt;&gt;<i> <A HREF="https://github.com/PISAresearch/pisa/blob/master/13-watchtower-API.md">https://github.com/PISAresearch/pisa/blob/master/13-watchtower-API.md</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> Sergi.
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Lightning-dev mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>
-- 
Sergi.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191205/ca448e0e/attachment-0001.html">http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191205/ca448e0e/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002357.html">[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol
</A></li>
	<LI>Next message: <A HREF="002368.html">[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2367">[ date ]</a>
              <a href="thread.html#2367">[ thread ]</a>
              <a href="subject.html#2367">[ subject ]</a>
              <a href="author.html#2367">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>

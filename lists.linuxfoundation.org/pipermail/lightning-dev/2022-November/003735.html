<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] Dynamic Commitments Part 2: Taprooty Edition
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20Dynamic%20Commitments%20Part%202%3A%20Taprooty%20Edition&In-Reply-To=%3Cf4ee87a5-af09-2955-5c39-f722d6e83804%40mattcorallo.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003750.html">
   <LINK REL="Next"  HREF="003736.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] Dynamic Commitments Part 2: Taprooty Edition</H1>
    <B>Matt Corallo</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20Dynamic%20Commitments%20Part%202%3A%20Taprooty%20Edition&In-Reply-To=%3Cf4ee87a5-af09-2955-5c39-f722d6e83804%40mattcorallo.com%3E"
       TITLE="[Lightning-dev] Dynamic Commitments Part 2: Taprooty Edition">lf-lists at mattcorallo.com
       </A><BR>
    <I>Tue Nov  1 22:59:08 UTC 2022</I>
    <P><UL>
        <LI>Previous message: <A HREF="003750.html">[Lightning-dev] Fat Errors
</A></li>
        <LI>Next message: <A HREF="003736.html">[Lightning-dev] Watchtower-Free Lightning Channels For Casual	Users
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3735">[ date ]</a>
              <a href="thread.html#3735">[ thread ]</a>
              <a href="subject.html#3735">[ subject ]</a>
              <a href="author.html#3735">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Right, I kinda assume let's figure that out when we get PTLCs? There's also the channel-upgrade work 
that has been around for a while. Once we do that we can probably define a new type for PTLCs in 
&quot;normal&quot; channels.

Adding two types adds a bunch of complexity right now, and it would be effectively dead code that 
we're not likely to get right unless we have an immediate use/test for it. It is a good point, 
though, and something implementors should likely keep in mind when writing code.

Matt

On 10/28/22 12:35 AM, Johan Tor&#229;s Halseth wrote:
&gt;<i> Hi, Matt.
</I>&gt;<i> 
</I>&gt;<i> You're correct, I made the suggestion mainly because it would open up for PTLCs (or other future 
</I>&gt;<i> features) in today's channels.
</I>&gt;<i> 
</I>&gt;<i> Having the existing network close and reopen new channels would really slow the adoption of new 
</I>&gt;<i> channel features I reckon.
</I>&gt;<i> 
</I>&gt;<i> And I don't think it adds much complexity compared to the adapter approach.
</I>&gt;<i> 
</I>&gt;<i> - Johan
</I>&gt;<i> 
</I>&gt;<i> On Thu, Oct 27, 2022 at 4:54 PM Matt Corallo &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lf-lists at mattcorallo.com</A> 
</I>&gt;<i> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lf-lists at mattcorallo.com</A>&gt;&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i>     I&#8217;m not sure I understand this - is there much reason to want taproot commitment outputs? I mean
</I>&gt;<i>     they&#8217;re cool, and witnesses are a bit smaller, which is nice I guess, but they&#8217;re not providing
</I>&gt;<i>     materially new features, AFAIU. Taproot funding, on the other hand, provides a Bitcoin-wide
</I>&gt;<i>     privacy improvement as well the potential future ability of channel participants to use multisig
</I>&gt;<i>     for their own channel funds transparently.
</I>&gt;<i> 
</I>&gt;<i>     Sure, if we&#8217;re doing taproot funding outputs we should probably just do it for the commitment
</I>&gt;<i>     outputs as well, because why not (and it&#8217;s a prereq for PTLCs). But trying to split them up
</I>&gt;<i>     seems like added complexity &#8220;just because&#8221;? I suppose it tees us up for eventual PTLC support in
</I>&gt;<i>     todays channels, but we can also consider that separately when we get to that point, IMO.
</I>&gt;<i> 
</I>&gt;<i>     Am I missing some important utility of taproot commitment transaction outputs?
</I>&gt;<i> 
</I>&gt;<i>     Matt
</I>&gt;<i> 
</I>&gt;&gt;<i>     On Oct 27, 2022, at 02:17, Johan Tor&#229;s Halseth &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">johanth at gmail.com</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">johanth at gmail.com</A>&gt;&gt;
</I>&gt;&gt;<i>     wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     &#65279;
</I>&gt;&gt;<i>     Hi, Laolu.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     I think it could be worth considering dividing the taprootyness of a channel into two:
</I>&gt;&gt;<i>     1) taproot funding output
</I>&gt;&gt;<i>     2) taproot commitment outputs
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     That way we could upgrade existing channels only on the commitment level, not needing to close
</I>&gt;&gt;<i>     or re-anchor the channels using an adapter in order to get many of the taproot benefits.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     New channels would use taproot multisig (musig2) for the funding output.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     This seems to be less disruptive to the existing network, and we could get features enabled by
</I>&gt;&gt;<i>     taproot to larger parts of the network quicker. And to me this seems to carry less complexity
</I>&gt;&gt;<i>     (and closing fees) than an adapter.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     One caveat is that this wouldn't work (I think) for Eltoo channels, as the funding output
</I>&gt;&gt;<i>     would not be plain multisig anymore.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     - Johan
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     On Sat, Mar 26, 2022 at 1:27 AM Antoine Riard &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">antoine.riard at gmail.com</A>
</I>&gt;&gt;<i>     &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">antoine.riard at gmail.com</A>&gt;&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Hi Laolu,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Thanks for the proposal, quick feedback.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; It *is* still the case that _ultimately_ the two transactions to close the
</I>&gt;&gt;<i>         &gt; old segwit v0 funding output, and re-open the channel with a new segwit v1
</I>&gt;&gt;<i>         &gt; funding output are unavoidable. However this adapter commitment lets peers
</I>&gt;&gt;<i>         &gt; _defer_ these two transactions until closing time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         I think there is one downside coming with adapter commitment, which is the uncertainty of
</I>&gt;&gt;<i>         the fee overhead at the closing time. Instead of closing your segwit v0 channel _now_ with
</I>&gt;&gt;<i>         known fees, when your commitment is empty of time-sensitive HTLCs, you're taking the risk
</I>&gt;&gt;<i>         of closing during fees spikes, due a move triggered by your counterparty, when you might
</I>&gt;&gt;<i>         have HTLCs at stake.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         It might be more economically rational for a LN node operator to pay the upgrade cost now
</I>&gt;&gt;<i>         if they wish&#160; to benefit from the taproot upgrade early, especially if long-term we expect
</I>&gt;&gt;<i>         block fees to increase, or wait when there is a &quot;normal&quot; cooperative closing.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         So it's unclear to me what the economic gain of adapter commitments ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; In the remainder of this mail, I'll describe an alternative
</I>&gt;&gt;<i>         &gt; approach that would allow upgrading nearly all channel/commitment related
</I>&gt;&gt;<i>         &gt; values (dust limit, max in flight, etc), which is inspired by the way the
</I>&gt;&gt;<i>         &gt; Raft consensus protocol handles configuration/member changes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Long-term, I think we'll likely need a consensus protocol anyway for multi-party
</I>&gt;&gt;<i>         constructions (channel factories/payment pools). AFAIU this proposal doesn't aim to roll
</I>&gt;&gt;<i>         out a full-fledged consensus protocol *now* though it could be wise to ensure what we're
</I>&gt;&gt;<i>         building slowly moves in this direction. Less critical code to maintain across bitcoin
</I>&gt;&gt;<i>         codebases/toolchains.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; The role of the signature it to prevent &quot;spoofing&quot; by one of the parties
</I>&gt;&gt;<i>         &gt; (authenticate the param change), and also it serves to convince a party that
</I>&gt;&gt;<i>         &gt; they actually sent a prior commitment propose update during the
</I>&gt;&gt;<i>         &gt; retransmission phase.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         What's the purpose of data origin authentication if we assume only two-parties running
</I>&gt;&gt;<i>         over Noise_XK ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         I think it's already a security property we have. Though if we think we're going to reuse
</I>&gt;&gt;<i>         these dynamic upgrades for N counterparties communicating through a coordinator, yes I
</I>&gt;&gt;<i>         think it's useful.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; In the past, when ideas like this were brought up, some were concerned that
</I>&gt;&gt;<i>         &gt; it wouldn't really be possible to do this type of updates while existing
</I>&gt;&gt;<i>         &gt; HTLCs were in flight (hence some of the ideas to clear out the commitment
</I>&gt;&gt;<i>         &gt; beforehand).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         The dynamic upgrade might serve in an emergency context where we don't have the leisury to
</I>&gt;&gt;<i>         wait for the settlement of the pending HTLCs. The timing of those ones might be beyond the
</I>&gt;&gt;<i>         coordination of link counterparties. Thus, we have to allow upgrade of non-empty
</I>&gt;&gt;<i>         commitments (and if there are undesirable interferences between new commitment types and
</I>&gt;&gt;<i>         HTLCs/PTLCs present, deal case-by-case).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Antoine
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Le&#160;jeu. 24 mars 2022 &#224;&#160;18:53, Olaoluwa Osuntokun &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>
</I>&gt;&gt;<i>         &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>&gt;&gt; a &#233;crit&#160;:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Hi y'all,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Dynamic Commitments Retrospective
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Two years-ish ago I made a mailing list post on some ideas re dynamic
</I>&gt;&gt;<i>             commitments [1], and how the concept can be used to allow us to upgrade
</I>&gt;&gt;<i>             channel types on the fly, and also remove pesky hard coded limits like the
</I>&gt;&gt;<i>             483 HTLC in-flight limit that's present today. Back then my main target was
</I>&gt;&gt;<i>             upgrading all the existing channels over to the anchor output commitment
</I>&gt;&gt;<i>             variant, so the core internal routing network would be more resilient in a
</I>&gt;&gt;<i>             persistent high fee environment (which hasn't really happened over the past
</I>&gt;&gt;<i>             2 years for various reasons tbh). Fast forward to today, and with taproot
</I>&gt;&gt;<i>             now active on mainnet, and some initial design work/sketches for
</I>&gt;&gt;<i>             taproot-native channels underway, I figure it would be good to bump this
</I>&gt;&gt;<i>             concept as it gives us a way to upgrade all 80k+ public channels to taproot
</I>&gt;&gt;<i>             without any on chain transactions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Updating Across Witness Versions w/ Adapter Commitments
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             In my original mail, I incorrectly concluded that the dynamic commitments
</I>&gt;&gt;<i>             concept would only really work within the confines of a &quot;static&quot; multi-sig
</I>&gt;&gt;<i>             output, meaning that it couldn't be used to help channels upgrade to future
</I>&gt;&gt;<i>             segwit witness versions.&#160; Thankfully this reply [2] by ZmnSCPxj, outlined a
</I>&gt;&gt;<i>             way to achieve this in practice. At a high level he proposes an &quot;adaptor
</I>&gt;&gt;<i>             commitment&quot; (similar to the kickoff transaction in eltoo/duplex), which is
</I>&gt;&gt;<i>             basically an upgrade transaction that spends one witness version type, and
</I>&gt;&gt;<i>             produces an output with the next (upgraded) type. In the context of
</I>&gt;&gt;<i>             converting from segwit v0 to v1 (taproot), two peers would collaboratively
</I>&gt;&gt;<i>             create a new adapter commitment that spends the old v0 multi-sig output, and
</I>&gt;&gt;<i>             produces a _new_ v1 multi-sig output. The new commitment transaction would
</I>&gt;&gt;<i>             then be anchored using this new output.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Here's a rough sequence diagram of the before and after state to better
</I>&gt;&gt;<i>             convey the concept:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             &#160; * Before: fundingOutputV0 -&gt; commitmentTransaction
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             &#160; * After fundingOutputV0 -&gt; fundingOutputV1 (the adapter) -&gt;
</I>&gt;&gt;<i>             &#160; &#160; commitmentTransaction
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             It *is* still the case that _ultimately_ the two transactions to close the
</I>&gt;&gt;<i>             old segwit v0 funding output, and re-open the channel with a new segwit v1
</I>&gt;&gt;<i>             funding output are unavoidable. However this adapter commitment lets peers
</I>&gt;&gt;<i>             _defer_ these two transactions until closing time. When force closing two
</I>&gt;&gt;<i>             transactions need to be confirmed before the commitment outputs can be
</I>&gt;&gt;<i>             resolved. However, for co-op close, you can just spend the v0 output, and
</I>&gt;&gt;<i>             deliver to the relevant P2TR outputs. The adapter commitment can leverage
</I>&gt;&gt;<i>             sighash anyonecanpay to let both parties (assuming it's symmetric) attach
</I>&gt;&gt;<i>             additional inputs for fees (to avoid introducing the old update_fee related
</I>&gt;&gt;<i>             static fee issues), or alternatively inherit the anchor output pattern at
</I>&gt;&gt;<i>             this level.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Existing Dynamic Commitments Proposals
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Assuming this concept holds up, then we need an actual concrete protocol to
</I>&gt;&gt;<i>             allow for dynamic commitment updates. Last year, Rusty made a spec PR
</I>&gt;&gt;<i>             outlining a way to upgrade the commitment type (leveraging the new
</I>&gt;&gt;<i>             commitment type feature bits) upon channel re-establish [3]. The proposal
</I>&gt;&gt;<i>             relies on another message that both sides send (`stfu`) to clear the
</I>&gt;&gt;<i>             commitment (similar to the shutdown semantics) before the switch over
</I>&gt;&gt;<i>             happens. However as this is tied to the channel re-establish flow, it
</I>&gt;&gt;<i>             doesn't allow both sides to do things like only allow your peer to attach N
</I>&gt;&gt;<i>             HTLCs to start with, slowing increasing their allotted slots and possibly
</I>&gt;&gt;<i>             reducing them (TCP AIMD style).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## A Two-Phase Dynamic Commitment Update Protocol
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             IMO if we're adding in a way to do commitment/channel upgrades, then it may
</I>&gt;&gt;<i>             be worthwhile to go with a more generalized, but slightly more involved
</I>&gt;&gt;<i>             route instead. In the remainder of this mail, I'll describe an alternative
</I>&gt;&gt;<i>             approach that would allow upgrading nearly all channel/commitment related
</I>&gt;&gt;<i>             values (dust limit, max in flight, etc), which is inspired by the way the
</I>&gt;&gt;<i>             Raft consensus protocol handles configuration/member changes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             For those that aren't aware, Raft is a consensus protocol analogous to Paxos
</I>&gt;&gt;<i>             (but isn't byzantine fault tolerant out of the box) that was designed as a
</I>&gt;&gt;<i>             more understandable alternative to Paxos for a pedagogical environment.
</I>&gt;&gt;<i>             Typically the algorithm is run in the context of a fixed cluster with N
</I>&gt;&gt;<i>             machines, but supports adding/removing machines from the cluster with a
</I>&gt;&gt;<i>             configuration update protocol. At a high level the way this works is that a
</I>&gt;&gt;<i>             new config is sent to the leader, with the leader synchronizing the config
</I>&gt;&gt;<i>             change with the other members of the cluster. Once a majority threshold is
</I>&gt;&gt;<i>             reached, the leader then commits the config change with the acknowledged
</I>&gt;&gt;<i>             parties using the new config (basically a two phase commit). I'm skipping
</I>&gt;&gt;<i>             over some edge cases here that can arise if the new nodes participate
</I>&gt;&gt;<i>             consensus too early, which can cause a split majority leading to two leaders
</I>&gt;&gt;<i>             being elected.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Applying this to the LN context is a bit simpler than a generalized
</I>&gt;&gt;<i>             protocol, as we typically just have two parties involved. The initiator is
</I>&gt;&gt;<i>             already naturally a &quot;leader&quot; in our context, as they're the only ones that
</I>&gt;&gt;<i>             can do things like trigger fee updates.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Message Structure
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             At a high level I propose we introduce two new messages, with the fields
</I>&gt;&gt;<i>             looking something like this for `commitment_update_propose`:
</I>&gt;&gt;<i>             &#160;* type: 0 (`channel_id`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`32*byte`:`chan_id`]
</I>&gt;&gt;<i>             &#160;* type: 1 (`propose_sig`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`64*byte`:`sig`]
</I>&gt;&gt;<i>             &#160;* type: 2 (`update_payload`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`tlv_payload`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             and this `commitment_update_apply`:
</I>&gt;&gt;<i>             &#160;* type: 0 (`channel_id`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`32*byte`:`chan_id`]
</I>&gt;&gt;<i>             &#160;* type: 1 (`local_propose`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`commitment_update_propose`]
</I>&gt;&gt;<i>             &#160;* type: 2 (`remote_propose`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`commitment_update_propose`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Protocol Flow
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The core idea here is that either party can propose a commitment/channel
</I>&gt;&gt;<i>             param update, but only the initiator can actually apply it. The
</I>&gt;&gt;<i>             `commitment_update_propose` encodes the new set of updates, with a signature
</I>&gt;&gt;<i>             covering the TLV blob for the new params (more on why that's needed later).
</I>&gt;&gt;<i>             The `commitment_update_apply` includes up to _two_
</I>&gt;&gt;<i>             `commitment_update_propose` messages (one for the initiator and one for the
</I>&gt;&gt;<i>             responder, as nested TLV messages). The `commitment_update_propose` message
</I>&gt;&gt;<i>             would be treated like any other `update_*` message, in that it takes a new
</I>&gt;&gt;<i>             commitment signature to properly commit/apply it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The normal flow takes the form of both sides sending a
</I>&gt;&gt;<i>             `commitment_update_propose` message, with the initiator finally committing
</I>&gt;&gt;<i>             both by sending a `commitment_update_apply` message. In the event that only
</I>&gt;&gt;<i>             the responder wants to apply a param change/update, then the initiator can
</I>&gt;&gt;<i>             reply immediately with a `commitment_update_apply` message that doesn't
</I>&gt;&gt;<i>             include a param change for their commitment (or they just echo the
</I>&gt;&gt;<i>             parameters if they're acceptable).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Handling Retransmissions
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The role of the signature it to prevent &quot;spoofing&quot; by one of the parties
</I>&gt;&gt;<i>             (authenticate the param change), and also it serves to convince a party that
</I>&gt;&gt;<i>             they actually sent a prior commitment propose update during the
</I>&gt;&gt;<i>             retransmission phase. As the `commitment_update_propose` message would be
</I>&gt;&gt;<i>             retransmitted like any other message, if the initiator attempts to commit
</I>&gt;&gt;<i>             the update but the connection dies, they'll retransmit it as normal along
</I>&gt;&gt;<i>             with their latest signature.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Nested TLV Param Generality
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The messages as sketched out here just have an opaque nested TLV field which
</I>&gt;&gt;<i>             makes it extensible to add in other things like tweaking the total number of
</I>&gt;&gt;<i>             max HTLCs, the current dust values, min/max HTLCs, etc (all things that are
</I>&gt;&gt;<i>             currently hard coded for the lifetime of the channel). An initial target
</I>&gt;&gt;<i>             would likely just be a `chan_type` field, with future feature bits governing
</I>&gt;&gt;<i>             _what_ type of commitment updates both parties understand in the future.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             In the past, when ideas like this were brought up, some were concerned that
</I>&gt;&gt;<i>             it wouldn't really be possible to do this type of updates while existing
</I>&gt;&gt;<i>             HTLCs were in flight (hence some of the ideas to clear out the commitment
</I>&gt;&gt;<i>             beforehand). I don't see a reason why this fundamentally _shouldn't_ be
</I>&gt;&gt;<i>             allowed, as from the point of view of the channel update state machine, all
</I>&gt;&gt;<i>             updates (adds/removes) get applied as normal, but with this _new_ commitment
</I>&gt;&gt;<i>             type/params. The main edge case we'll need to consider is cases where the
</I>&gt;&gt;<i>             new params make older HTLCs invalid for some reason.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Conclusion
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Using the adapter commitment idea combined with a protocol for updating
</I>&gt;&gt;<i>             commitments on the fly, would potentially allow us to update all 80k+ segwit
</I>&gt;&gt;<i>             v0 channels to the base level of taprooty channels without any on chain
</I>&gt;&gt;<i>             transactions. The two transactions (open+close) must happen eventually, but
</I>&gt;&gt;<i>             by holding another layer of spends off-chain we can defer them (potentially
</I>&gt;&gt;<i>             indefinitely, as we have channels today that have been opened for over a
</I>&gt;&gt;<i>             year).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Deploying a generalised on-the-fly dynamic commitment update protocol gives
</I>&gt;&gt;<i>             us a tool to future proof the _existing_ anchored multi-sig outputs in the
</I>&gt;&gt;<i>             chain, and also a way to remove many of the hard coded parameters we have
</I>&gt;&gt;<i>             today in the protocol. One overly inflexible parameter we have today in the
</I>&gt;&gt;<i>             network is the 483 HTLC limit. Allowing this value to float would allow
</I>&gt;&gt;<i>             peers to apply similar congestion avoidance algorithm that are used in TCP
</I>&gt;&gt;<i>             today, and also give us a way to protect the network against future
</I>&gt;&gt;<i>             unforeseen widespread policy changes (like a raising of the dust limit).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             -- Laolu
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             [1]: <A HREF="../2020-July/002763.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002763.html</A>
</I>&gt;&gt;<i>             &lt;<A HREF="../2020-July/002763.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002763.html</A>&gt;
</I>&gt;&gt;<i>             [2]: <A HREF="../2020-July/002770.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002770.html</A>
</I>&gt;&gt;<i>             &lt;<A HREF="../2020-July/002770.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002770.html</A>&gt;
</I>&gt;&gt;<i>             [3]: <A HREF="https://github.com/lightning/bolts/pull/868">https://github.com/lightning/bolts/pull/868</A>
</I>&gt;&gt;<i>             &lt;<A HREF="https://github.com/lightning/bolts/pull/868">https://github.com/lightning/bolts/pull/868</A>&gt;
</I>&gt;&gt;<i>             _______________________________________________
</I>&gt;&gt;<i>             Lightning-dev mailing list
</I>&gt;&gt;<i>             <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>             <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>             &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         _______________________________________________
</I>&gt;&gt;<i>         Lightning-dev mailing list
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     _______________________________________________
</I>&gt;&gt;<i>     Lightning-dev mailing list
</I>&gt;&gt;<i>     <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>     <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>     &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On Thu, Oct 27, 2022 at 4:54 PM Matt Corallo &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lf-lists at mattcorallo.com</A> 
</I>&gt;<i> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lf-lists at mattcorallo.com</A>&gt;&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i>     I&#8217;m not sure I understand this - is there much reason to want taproot commitment outputs? I mean
</I>&gt;<i>     they&#8217;re cool, and witnesses are a bit smaller, which is nice I guess, but they&#8217;re not providing
</I>&gt;<i>     materially new features, AFAIU. Taproot funding, on the other hand, provides a Bitcoin-wide
</I>&gt;<i>     privacy improvement as well the potential future ability of channel participants to use multisig
</I>&gt;<i>     for their own channel funds transparently.
</I>&gt;<i> 
</I>&gt;<i>     Sure, if we&#8217;re doing taproot funding outputs we should probably just do it for the commitment
</I>&gt;<i>     outputs as well, because why not (and it&#8217;s a prereq for PTLCs). But trying to split them up
</I>&gt;<i>     seems like added complexity &#8220;just because&#8221;? I suppose it tees us up for eventual PTLC support in
</I>&gt;<i>     todays channels, but we can also consider that separately when we get to that point, IMO.
</I>&gt;<i> 
</I>&gt;<i>     Am I missing some important utility of taproot commitment transaction outputs?
</I>&gt;<i> 
</I>&gt;<i>     Matt
</I>&gt;<i> 
</I>&gt;&gt;<i>     On Oct 27, 2022, at 02:17, Johan Tor&#229;s Halseth &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">johanth at gmail.com</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">johanth at gmail.com</A>&gt;&gt;
</I>&gt;&gt;<i>     wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     &#65279;
</I>&gt;&gt;<i>     Hi, Laolu.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     I think it could be worth considering dividing the taprootyness of a channel into two:
</I>&gt;&gt;<i>     1) taproot funding output
</I>&gt;&gt;<i>     2) taproot commitment outputs
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     That way we could upgrade existing channels only on the commitment level, not needing to close
</I>&gt;&gt;<i>     or re-anchor the channels using an adapter in order to get many of the taproot benefits.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     New channels would use taproot multisig (musig2) for the funding output.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     This seems to be less disruptive to the existing network, and we could get features enabled by
</I>&gt;&gt;<i>     taproot to larger parts of the network quicker. And to me this seems to carry less complexity
</I>&gt;&gt;<i>     (and closing fees) than an adapter.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     One caveat is that this wouldn't work (I think) for Eltoo channels, as the funding output
</I>&gt;&gt;<i>     would not be plain multisig anymore.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     - Johan
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     On Sat, Mar 26, 2022 at 1:27 AM Antoine Riard &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">antoine.riard at gmail.com</A>
</I>&gt;&gt;<i>     &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">antoine.riard at gmail.com</A>&gt;&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Hi Laolu,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Thanks for the proposal, quick feedback.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; It *is* still the case that _ultimately_ the two transactions to close the
</I>&gt;&gt;<i>         &gt; old segwit v0 funding output, and re-open the channel with a new segwit v1
</I>&gt;&gt;<i>         &gt; funding output are unavoidable. However this adapter commitment lets peers
</I>&gt;&gt;<i>         &gt; _defer_ these two transactions until closing time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         I think there is one downside coming with adapter commitment, which is the uncertainty of
</I>&gt;&gt;<i>         the fee overhead at the closing time. Instead of closing your segwit v0 channel _now_ with
</I>&gt;&gt;<i>         known fees, when your commitment is empty of time-sensitive HTLCs, you're taking the risk
</I>&gt;&gt;<i>         of closing during fees spikes, due a move triggered by your counterparty, when you might
</I>&gt;&gt;<i>         have HTLCs at stake.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         It might be more economically rational for a LN node operator to pay the upgrade cost now
</I>&gt;&gt;<i>         if they wish&#160; to benefit from the taproot upgrade early, especially if long-term we expect
</I>&gt;&gt;<i>         block fees to increase, or wait when there is a &quot;normal&quot; cooperative closing.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         So it's unclear to me what the economic gain of adapter commitments ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; In the remainder of this mail, I'll describe an alternative
</I>&gt;&gt;<i>         &gt; approach that would allow upgrading nearly all channel/commitment related
</I>&gt;&gt;<i>         &gt; values (dust limit, max in flight, etc), which is inspired by the way the
</I>&gt;&gt;<i>         &gt; Raft consensus protocol handles configuration/member changes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Long-term, I think we'll likely need a consensus protocol anyway for multi-party
</I>&gt;&gt;<i>         constructions (channel factories/payment pools). AFAIU this proposal doesn't aim to roll
</I>&gt;&gt;<i>         out a full-fledged consensus protocol *now* though it could be wise to ensure what we're
</I>&gt;&gt;<i>         building slowly moves in this direction. Less critical code to maintain across bitcoin
</I>&gt;&gt;<i>         codebases/toolchains.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; The role of the signature it to prevent &quot;spoofing&quot; by one of the parties
</I>&gt;&gt;<i>         &gt; (authenticate the param change), and also it serves to convince a party that
</I>&gt;&gt;<i>         &gt; they actually sent a prior commitment propose update during the
</I>&gt;&gt;<i>         &gt; retransmission phase.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         What's the purpose of data origin authentication if we assume only two-parties running
</I>&gt;&gt;<i>         over Noise_XK ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         I think it's already a security property we have. Though if we think we're going to reuse
</I>&gt;&gt;<i>         these dynamic upgrades for N counterparties communicating through a coordinator, yes I
</I>&gt;&gt;<i>         think it's useful.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         &gt; In the past, when ideas like this were brought up, some were concerned that
</I>&gt;&gt;<i>         &gt; it wouldn't really be possible to do this type of updates while existing
</I>&gt;&gt;<i>         &gt; HTLCs were in flight (hence some of the ideas to clear out the commitment
</I>&gt;&gt;<i>         &gt; beforehand).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         The dynamic upgrade might serve in an emergency context where we don't have the leisury to
</I>&gt;&gt;<i>         wait for the settlement of the pending HTLCs. The timing of those ones might be beyond the
</I>&gt;&gt;<i>         coordination of link counterparties. Thus, we have to allow upgrade of non-empty
</I>&gt;&gt;<i>         commitments (and if there are undesirable interferences between new commitment types and
</I>&gt;&gt;<i>         HTLCs/PTLCs present, deal case-by-case).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Antoine
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         Le&#160;jeu. 24 mars 2022 &#224;&#160;18:53, Olaoluwa Osuntokun &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>
</I>&gt;&gt;<i>         &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>&gt;&gt; a &#233;crit&#160;:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Hi y'all,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Dynamic Commitments Retrospective
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Two years-ish ago I made a mailing list post on some ideas re dynamic
</I>&gt;&gt;<i>             commitments [1], and how the concept can be used to allow us to upgrade
</I>&gt;&gt;<i>             channel types on the fly, and also remove pesky hard coded limits like the
</I>&gt;&gt;<i>             483 HTLC in-flight limit that's present today. Back then my main target was
</I>&gt;&gt;<i>             upgrading all the existing channels over to the anchor output commitment
</I>&gt;&gt;<i>             variant, so the core internal routing network would be more resilient in a
</I>&gt;&gt;<i>             persistent high fee environment (which hasn't really happened over the past
</I>&gt;&gt;<i>             2 years for various reasons tbh). Fast forward to today, and with taproot
</I>&gt;&gt;<i>             now active on mainnet, and some initial design work/sketches for
</I>&gt;&gt;<i>             taproot-native channels underway, I figure it would be good to bump this
</I>&gt;&gt;<i>             concept as it gives us a way to upgrade all 80k+ public channels to taproot
</I>&gt;&gt;<i>             without any on chain transactions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Updating Across Witness Versions w/ Adapter Commitments
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             In my original mail, I incorrectly concluded that the dynamic commitments
</I>&gt;&gt;<i>             concept would only really work within the confines of a &quot;static&quot; multi-sig
</I>&gt;&gt;<i>             output, meaning that it couldn't be used to help channels upgrade to future
</I>&gt;&gt;<i>             segwit witness versions.&#160; Thankfully this reply [2] by ZmnSCPxj, outlined a
</I>&gt;&gt;<i>             way to achieve this in practice. At a high level he proposes an &quot;adaptor
</I>&gt;&gt;<i>             commitment&quot; (similar to the kickoff transaction in eltoo/duplex), which is
</I>&gt;&gt;<i>             basically an upgrade transaction that spends one witness version type, and
</I>&gt;&gt;<i>             produces an output with the next (upgraded) type. In the context of
</I>&gt;&gt;<i>             converting from segwit v0 to v1 (taproot), two peers would collaboratively
</I>&gt;&gt;<i>             create a new adapter commitment that spends the old v0 multi-sig output, and
</I>&gt;&gt;<i>             produces a _new_ v1 multi-sig output. The new commitment transaction would
</I>&gt;&gt;<i>             then be anchored using this new output.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Here's a rough sequence diagram of the before and after state to better
</I>&gt;&gt;<i>             convey the concept:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             &#160; * Before: fundingOutputV0 -&gt; commitmentTransaction
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             &#160; * After fundingOutputV0 -&gt; fundingOutputV1 (the adapter) -&gt;
</I>&gt;&gt;<i>             &#160; &#160; commitmentTransaction
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             It *is* still the case that _ultimately_ the two transactions to close the
</I>&gt;&gt;<i>             old segwit v0 funding output, and re-open the channel with a new segwit v1
</I>&gt;&gt;<i>             funding output are unavoidable. However this adapter commitment lets peers
</I>&gt;&gt;<i>             _defer_ these two transactions until closing time. When force closing two
</I>&gt;&gt;<i>             transactions need to be confirmed before the commitment outputs can be
</I>&gt;&gt;<i>             resolved. However, for co-op close, you can just spend the v0 output, and
</I>&gt;&gt;<i>             deliver to the relevant P2TR outputs. The adapter commitment can leverage
</I>&gt;&gt;<i>             sighash anyonecanpay to let both parties (assuming it's symmetric) attach
</I>&gt;&gt;<i>             additional inputs for fees (to avoid introducing the old update_fee related
</I>&gt;&gt;<i>             static fee issues), or alternatively inherit the anchor output pattern at
</I>&gt;&gt;<i>             this level.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Existing Dynamic Commitments Proposals
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Assuming this concept holds up, then we need an actual concrete protocol to
</I>&gt;&gt;<i>             allow for dynamic commitment updates. Last year, Rusty made a spec PR
</I>&gt;&gt;<i>             outlining a way to upgrade the commitment type (leveraging the new
</I>&gt;&gt;<i>             commitment type feature bits) upon channel re-establish [3]. The proposal
</I>&gt;&gt;<i>             relies on another message that both sides send (`stfu`) to clear the
</I>&gt;&gt;<i>             commitment (similar to the shutdown semantics) before the switch over
</I>&gt;&gt;<i>             happens. However as this is tied to the channel re-establish flow, it
</I>&gt;&gt;<i>             doesn't allow both sides to do things like only allow your peer to attach N
</I>&gt;&gt;<i>             HTLCs to start with, slowing increasing their allotted slots and possibly
</I>&gt;&gt;<i>             reducing them (TCP AIMD style).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## A Two-Phase Dynamic Commitment Update Protocol
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             IMO if we're adding in a way to do commitment/channel upgrades, then it may
</I>&gt;&gt;<i>             be worthwhile to go with a more generalized, but slightly more involved
</I>&gt;&gt;<i>             route instead. In the remainder of this mail, I'll describe an alternative
</I>&gt;&gt;<i>             approach that would allow upgrading nearly all channel/commitment related
</I>&gt;&gt;<i>             values (dust limit, max in flight, etc), which is inspired by the way the
</I>&gt;&gt;<i>             Raft consensus protocol handles configuration/member changes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             For those that aren't aware, Raft is a consensus protocol analogous to Paxos
</I>&gt;&gt;<i>             (but isn't byzantine fault tolerant out of the box) that was designed as a
</I>&gt;&gt;<i>             more understandable alternative to Paxos for a pedagogical environment.
</I>&gt;&gt;<i>             Typically the algorithm is run in the context of a fixed cluster with N
</I>&gt;&gt;<i>             machines, but supports adding/removing machines from the cluster with a
</I>&gt;&gt;<i>             configuration update protocol. At a high level the way this works is that a
</I>&gt;&gt;<i>             new config is sent to the leader, with the leader synchronizing the config
</I>&gt;&gt;<i>             change with the other members of the cluster. Once a majority threshold is
</I>&gt;&gt;<i>             reached, the leader then commits the config change with the acknowledged
</I>&gt;&gt;<i>             parties using the new config (basically a two phase commit). I'm skipping
</I>&gt;&gt;<i>             over some edge cases here that can arise if the new nodes participate
</I>&gt;&gt;<i>             consensus too early, which can cause a split majority leading to two leaders
</I>&gt;&gt;<i>             being elected.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Applying this to the LN context is a bit simpler than a generalized
</I>&gt;&gt;<i>             protocol, as we typically just have two parties involved. The initiator is
</I>&gt;&gt;<i>             already naturally a &quot;leader&quot; in our context, as they're the only ones that
</I>&gt;&gt;<i>             can do things like trigger fee updates.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Message Structure
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             At a high level I propose we introduce two new messages, with the fields
</I>&gt;&gt;<i>             looking something like this for `commitment_update_propose`:
</I>&gt;&gt;<i>             &#160;* type: 0 (`channel_id`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`32*byte`:`chan_id`]
</I>&gt;&gt;<i>             &#160;* type: 1 (`propose_sig`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`64*byte`:`sig`]
</I>&gt;&gt;<i>             &#160;* type: 2 (`update_payload`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`tlv_payload`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             and this `commitment_update_apply`:
</I>&gt;&gt;<i>             &#160;* type: 0 (`channel_id`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`32*byte`:`chan_id`]
</I>&gt;&gt;<i>             &#160;* type: 1 (`local_propose`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`commitment_update_propose`]
</I>&gt;&gt;<i>             &#160;* type: 2 (`remote_propose`)
</I>&gt;&gt;<i>             &#160; &#160;* value: [`*byte`:`commitment_update_propose`]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Protocol Flow
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The core idea here is that either party can propose a commitment/channel
</I>&gt;&gt;<i>             param update, but only the initiator can actually apply it. The
</I>&gt;&gt;<i>             `commitment_update_propose` encodes the new set of updates, with a signature
</I>&gt;&gt;<i>             covering the TLV blob for the new params (more on why that's needed later).
</I>&gt;&gt;<i>             The `commitment_update_apply` includes up to _two_
</I>&gt;&gt;<i>             `commitment_update_propose` messages (one for the initiator and one for the
</I>&gt;&gt;<i>             responder, as nested TLV messages). The `commitment_update_propose` message
</I>&gt;&gt;<i>             would be treated like any other `update_*` message, in that it takes a new
</I>&gt;&gt;<i>             commitment signature to properly commit/apply it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The normal flow takes the form of both sides sending a
</I>&gt;&gt;<i>             `commitment_update_propose` message, with the initiator finally committing
</I>&gt;&gt;<i>             both by sending a `commitment_update_apply` message. In the event that only
</I>&gt;&gt;<i>             the responder wants to apply a param change/update, then the initiator can
</I>&gt;&gt;<i>             reply immediately with a `commitment_update_apply` message that doesn't
</I>&gt;&gt;<i>             include a param change for their commitment (or they just echo the
</I>&gt;&gt;<i>             parameters if they're acceptable).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Handling Retransmissions
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The role of the signature it to prevent &quot;spoofing&quot; by one of the parties
</I>&gt;&gt;<i>             (authenticate the param change), and also it serves to convince a party that
</I>&gt;&gt;<i>             they actually sent a prior commitment propose update during the
</I>&gt;&gt;<i>             retransmission phase. As the `commitment_update_propose` message would be
</I>&gt;&gt;<i>             retransmitted like any other message, if the initiator attempts to commit
</I>&gt;&gt;<i>             the update but the connection dies, they'll retransmit it as normal along
</I>&gt;&gt;<i>             with their latest signature.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ### Nested TLV Param Generality
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             The messages as sketched out here just have an opaque nested TLV field which
</I>&gt;&gt;<i>             makes it extensible to add in other things like tweaking the total number of
</I>&gt;&gt;<i>             max HTLCs, the current dust values, min/max HTLCs, etc (all things that are
</I>&gt;&gt;<i>             currently hard coded for the lifetime of the channel). An initial target
</I>&gt;&gt;<i>             would likely just be a `chan_type` field, with future feature bits governing
</I>&gt;&gt;<i>             _what_ type of commitment updates both parties understand in the future.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             In the past, when ideas like this were brought up, some were concerned that
</I>&gt;&gt;<i>             it wouldn't really be possible to do this type of updates while existing
</I>&gt;&gt;<i>             HTLCs were in flight (hence some of the ideas to clear out the commitment
</I>&gt;&gt;<i>             beforehand). I don't see a reason why this fundamentally _shouldn't_ be
</I>&gt;&gt;<i>             allowed, as from the point of view of the channel update state machine, all
</I>&gt;&gt;<i>             updates (adds/removes) get applied as normal, but with this _new_ commitment
</I>&gt;&gt;<i>             type/params. The main edge case we'll need to consider is cases where the
</I>&gt;&gt;<i>             new params make older HTLCs invalid for some reason.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             ## Conclusion
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Using the adapter commitment idea combined with a protocol for updating
</I>&gt;&gt;<i>             commitments on the fly, would potentially allow us to update all 80k+ segwit
</I>&gt;&gt;<i>             v0 channels to the base level of taprooty channels without any on chain
</I>&gt;&gt;<i>             transactions. The two transactions (open+close) must happen eventually, but
</I>&gt;&gt;<i>             by holding another layer of spends off-chain we can defer them (potentially
</I>&gt;&gt;<i>             indefinitely, as we have channels today that have been opened for over a
</I>&gt;&gt;<i>             year).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             Deploying a generalised on-the-fly dynamic commitment update protocol gives
</I>&gt;&gt;<i>             us a tool to future proof the _existing_ anchored multi-sig outputs in the
</I>&gt;&gt;<i>             chain, and also a way to remove many of the hard coded parameters we have
</I>&gt;&gt;<i>             today in the protocol. One overly inflexible parameter we have today in the
</I>&gt;&gt;<i>             network is the 483 HTLC limit. Allowing this value to float would allow
</I>&gt;&gt;<i>             peers to apply similar congestion avoidance algorithm that are used in TCP
</I>&gt;&gt;<i>             today, and also give us a way to protect the network against future
</I>&gt;&gt;<i>             unforeseen widespread policy changes (like a raising of the dust limit).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             -- Laolu
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>             [1]: <A HREF="../2020-July/002763.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002763.html</A>
</I>&gt;&gt;<i>             &lt;<A HREF="../2020-July/002763.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002763.html</A>&gt;
</I>&gt;&gt;<i>             [2]: <A HREF="../2020-July/002770.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002770.html</A>
</I>&gt;&gt;<i>             &lt;<A HREF="../2020-July/002770.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002770.html</A>&gt;
</I>&gt;&gt;<i>             [3]: <A HREF="https://github.com/lightning/bolts/pull/868">https://github.com/lightning/bolts/pull/868</A>
</I>&gt;&gt;<i>             &lt;<A HREF="https://github.com/lightning/bolts/pull/868">https://github.com/lightning/bolts/pull/868</A>&gt;
</I>&gt;&gt;<i>             _______________________________________________
</I>&gt;&gt;<i>             Lightning-dev mailing list
</I>&gt;&gt;<i>             <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>             <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>             &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         _______________________________________________
</I>&gt;&gt;<i>         Lightning-dev mailing list
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     _______________________________________________
</I>&gt;&gt;<i>     Lightning-dev mailing list
</I>&gt;&gt;<i>     <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A> &lt;mailto:<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i>     <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>     &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>&gt;
</I>&gt;<i> 
</I>
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003750.html">[Lightning-dev] Fat Errors
</A></li>
	<LI>Next message: <A HREF="003736.html">[Lightning-dev] Watchtower-Free Lightning Channels For Casual	Users
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3735">[ date ]</a>
              <a href="thread.html#3735">[ thread ]</a>
              <a href="subject.html#3735">[ subject ]</a>
              <a href="author.html#3735">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>

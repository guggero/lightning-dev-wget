<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] OpenCAP alias integrations with	invoices/destination
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-December/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20OpenCAP%20alias%20integrations%20with%0A%09invoices/destination&In-Reply-To=%3CJj0fdyRzJV7rKJLn45zjwIce1OBDAQ8nmhD814WLsZHeeBvYb8FBwUpVOZCQ73ZX1QfXD-HRTz0LlmFX1iOk-4ZvM1QCbFlRdkogPTboGIM%3D%40protonmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001729.html">
   <LINK REL="Next"  HREF="001736.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] OpenCAP alias integrations with	invoices/destination</H1>
    <B>ZmnSCPxj</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20OpenCAP%20alias%20integrations%20with%0A%09invoices/destination&In-Reply-To=%3CJj0fdyRzJV7rKJLn45zjwIce1OBDAQ8nmhD814WLsZHeeBvYb8FBwUpVOZCQ73ZX1QfXD-HRTz0LlmFX1iOk-4ZvM1QCbFlRdkogPTboGIM%3D%40protonmail.com%3E"
       TITLE="[Lightning-dev] OpenCAP alias integrations with	invoices/destination">ZmnSCPxj at protonmail.com
       </A><BR>
    <I>Sat Dec  8 19:13:59 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="001729.html">[Lightning-dev] OpenCAP alias integrations with invoices/destination
</A></li>
        <LI>Next message: <A HREF="001736.html">[Lightning-dev] [META] Organization of 1.1 Spec Effort
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1731">[ date ]</a>
              <a href="thread.html#1731">[ thread ]</a>
              <a href="subject.html#1731">[ subject ]</a>
              <a href="author.html#1731">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Good morning Lane,

I believe Rusty is creating a spec for reusable payment offers, which would let payers request for BOLT11 invoices over the LN network.
In addition, I believe Laolu and friends are building some spontaneous-payment protocol without proof-of-payment, although I am uncertain the details.

Regards,
ZmnSCPxj

Sent with [ProtonMail](<A HREF="https://protonmail.com">https://protonmail.com</A>) Secure Email.

&#8208;&#8208;&#8208;&#8208;&#8208;&#8208;&#8208; Original Message &#8208;&#8208;&#8208;&#8208;&#8208;&#8208;&#8208;
On Friday, December 7, 2018 9:14 PM, Lane Wagner &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lane.c.wagner at gmail.com</A>&gt; wrote:

&gt;<i> Im working on a protocol that allows users to host crypto public addresses, using a standard DNS lookup schema. It offers some advantages over OpenAlias and I'm hopeful that we will see actual adoption.
</I>&gt;<i>
</I>&gt;<i> I want users to be able to post lightning invoices as well, although I know this is difficult because typically invoices must be generated uniquely for each payment. I was thinking maybe posting a destination could be good, so that people can open channels with you, but then people with existing channels still couldnt send to you.
</I>&gt;<i>
</I>&gt;<i> Does anyone have thoughts on this?
</I>&gt;<i>
</I>&gt;<i> Protocol: <A HREF="https://GitHub.com/OpenCAP/protocol">https://GitHub.com/OpenCAP/protocol</A> (link to discord for discussion is there)
</I>&gt;<i>
</I>&gt;<i> Implementation: <A HREF="https://ogdolo.com">https://ogdolo.com</A>
</I>&gt;<i>
</I>&gt;<i> Open source implementation: <A HREF="https://GitHub.com/OpenCAP/go-server">https://GitHub.com/OpenCAP/go-server</A>
</I>&gt;<i>
</I>&gt;<i> On Fri, Dec 7, 2018, 5:00 AM &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-request at lists.linuxfoundation.org</A> wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Send Lightning-dev mailing list submissions to
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-request at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You can reach the person managing the list at
</I>&gt;&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-owner at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;&gt;<i> than &quot;Re: Contents of Lightning-dev digest...&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Today's Topics:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    1. Re: Reason for having HMACs in Sphinx (Christian Decker)
</I>&gt;&gt;<i>    2. Re: Fulgurite: ideas for making a more flexible   Lightning
</I>&gt;&gt;<i>       Network protocol (ZmnSCPxj)
</I>&gt;&gt;<i>    3. Fwd: Fulgurite: ideas for making a more flexible Lightning
</I>&gt;&gt;<i>       Network protocol (Trey Del Bonis)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ----------------------------------------------------------------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Message: 1
</I>&gt;&gt;<i> Date: Thu, 06 Dec 2018 16:24:20 +0100
</I>&gt;&gt;<i> From: Christian Decker &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">decker.christian at gmail.com</A>&gt;
</I>&gt;&gt;<i> To: Corn? Plooy &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">corne at bitonic.nl</A>&gt;, ZmnSCPxj    &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt;
</I>&gt;&gt;<i> Cc: &quot;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&quot;
</I>&gt;&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i> Subject: Re: [Lightning-dev] Reason for having HMACs in Sphinx
</I>&gt;&gt;<i> Message-ID: &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">875zw6adaz.fsf at gmail.com</A>&gt;
</I>&gt;&gt;<i> Content-Type: text/plain; charset=utf-8
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Corn? Plooy &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">corne at bitonic.nl</A>&gt; writes:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The total_decorrelation_secrets serves as the payer-generated shared
</I>&gt;&gt;&gt;&gt;<i> secret between payer and payee.  B cannot learn this, and thus cannot
</I>&gt;&gt;&gt;&gt;<i> fake its own secret.  Even if it instead offers ((I + K[A]) + k[z] *
</I>&gt;&gt;&gt;&gt;<i> G) for a new secret k[z], it cannot know how to change
</I>&gt;&gt;&gt;&gt;<i> total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The way things are now, the ephemeral key generation and the payment
</I>&gt;&gt;&gt;<i> hash/preimage generation are completely unrelated. This is what allows
</I>&gt;&gt;&gt;<i> an attacker to use the same payment hash, and use his own ephemeral key
</I>&gt;&gt;&gt;<i> pair to create a new onion packet around it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That is correct, one is generated by the recipient (secret and preimage)
</I>&gt;&gt;<i> and the other one is generated by the sender (ephemeral key). Mixing the
</I>&gt;&gt;<i> two seems very unwise, since the sender has very little control over
</I>&gt;&gt;<i> what the effective ephemeral key that is going to be used for the last
</I>&gt;&gt;<i> hop. This is the same issue that we have with rendez-vous routing, i.e.,
</I>&gt;&gt;<i> that if we require the ephemeral key to be something specific at a given
</I>&gt;&gt;<i> node we'd be breaking the hardness assumption of for the ephemeral key
</I>&gt;&gt;<i> rotation.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Primarily, path decorrelation replaces the payment hash/preimage part.
</I>&gt;&gt;&gt;<i> Maybe I still don't understand something, but if that's the only thing
</I>&gt;&gt;&gt;<i> (without changing the ephemeral key / onion shared secret generation),
</I>&gt;&gt;&gt;<i> attacking the direct neighbor should still work; in your case, B would
</I>&gt;&gt;&gt;<i> still offer ((I + K[A]) + K[B]) to C, with an onion packet B created
</I>&gt;&gt;&gt;<i> himself. I'm not familiar enough with the path correlation to understand
</I>&gt;&gt;&gt;<i> what happens after step 6, but for C it looks the same, so she should do
</I>&gt;&gt;&gt;<i> the same.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I do see that, if you couple the &quot;H&quot;TLC payment secret generation to the
</I>&gt;&gt;&gt;<i> onion shared secret generation, you can make the attack impossible. Do I
</I>&gt;&gt;&gt;<i> understand correctly that this is the idea? After all, C still needs to
</I>&gt;&gt;&gt;<i> receive k somehow; my crypto math isn't that good, but my intuitive
</I>&gt;&gt;&gt;<i> guess is that i + k is the secret that allows C to claim funds locked in
</I>&gt;&gt;&gt;<i> ((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A
</I>&gt;&gt;&gt;<i> to C through some mechanism that replaces the current ephemeral key
</I>&gt;&gt;&gt;<i> system, then I understand what you're at.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I can't quite follow where we would be mixing in the ephemeral key here,
</I>&gt;&gt;<i> could you elaborate on that?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Assuming this is the case, it's pretty neat. I do wonder how it
</I>&gt;&gt;&gt;<i> interacts with rendezvous routing. If the sender and receiver each
</I>&gt;&gt;&gt;<i> create the k[..] values for their own part of the route, can the
</I>&gt;&gt;&gt;<i> receiver-generated onion packet still use points of the form ((I + K[A])
</I>&gt;&gt;&gt;<i> + K[B]), including K[..] values related to the sender side? I need to
</I>&gt;&gt;&gt;<i> dig deeper into this path decorrelation idea.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Since we have very little control over what ephemeral key will actually
</I>&gt;&gt;<i> be presented to the last hop if we have a multi-hop route, we can't
</I>&gt;&gt;<i> really hide any information in the ephemeral key itself. What we could
</I>&gt;&gt;<i> do is change the way the last hop generates the shared secret from it,
</I>&gt;&gt;<i> i.e., have a last hop mode and a forwarding hop mode, and mix in the
</I>&gt;&gt;<i> payment secret somehow, but I can't think of a good way to do that, and
</I>&gt;&gt;<i> it seems contorted. Let's just have the sender prove knowledge of the
</I>&gt;&gt;<i> original invoice by adding a TLV field with a shared secret from the
</I>&gt;&gt;<i> invoice instead.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers,
</I>&gt;&gt;<i> Christian
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ------------------------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Message: 2
</I>&gt;&gt;<i> Date: Thu, 06 Dec 2018 23:22:57 +0000
</I>&gt;&gt;<i> From: ZmnSCPxj &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt;
</I>&gt;&gt;<i> To: Trey Del Bonis &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">j.delbonis.3 at gmail.com</A>&gt;
</I>&gt;&gt;<i> Cc: &quot;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&quot;
</I>&gt;&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;&gt;<i> Subject: Re: [Lightning-dev] Fulgurite: ideas for making a more
</I>&gt;&gt;<i>         flexible        Lightning Network protocol
</I>&gt;&gt;<i> Message-ID:
</I>&gt;&gt;<i>         &lt;qyU2TN0y6zXLjNtCrgEwlNjJh9WvMEnHLGoLEnS4c_9OXh8hyEn-gxnAwloz2cjUT1aedkonILtSJingtEucQYQiT6Y0wUgwZWkRmSKK_FA=@protonmail.com&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Good morning Trey,
</I>&gt;&gt;&gt;<i> One thing
</I>&gt;&gt;&gt;<i> we've talked about is if you and your counterparty want to route
</I>&gt;&gt;&gt;<i> payments through each other but also want to enter into discreet log
</I>&gt;&gt;&gt;<i> contracts, it might make sense to set up a subchannel for each purpose
</I>&gt;&gt;&gt;<i> so you don't have to re-sign for all the potential outcomes for the
</I>&gt;&gt;&gt;<i> DLCs (slow!) every time you add/remove an HTLC. Only the routing
</I>&gt;&gt;&gt;<i> (sub)channel would be announced to the routing network.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Of note, the routing gossip is not trust-based.
</I>&gt;&gt;<i> Instead, part of the routing gossip is the block and transaction and output on which the channel is anchored onchain.
</I>&gt;&gt;<i> Nodes check if the specified txo is unspent, and matches the purported capacity of the channel.
</I>&gt;&gt;<i> Once a channel outpoint is spent, nodes automatically remove it from their maps.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In a world with Burchert-Decker-Wattenhofer factories, the factory would have an onchain txo.
</I>&gt;&gt;<i> Gossip would contain all the channels in the factory, and would be signed by the same signatories as the onchain txo.
</I>&gt;&gt;<i> Nodes would check that the channels purported to be contained in the factory sum up to the value of this txo.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suppose that could be relaxed, so that the channels purported to be in the factory would sum up to less than or equal to the value of the channel factory txo instead.
</I>&gt;&gt;<i> This would allow a Fulgurite system to allocate only part of its funds to Lightning-visible routing nodes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It strikes me that the issue of re-signing the DLC subcontracts could be avoided if you use `SIGHASH_NOINPUT`.
</I>&gt;&gt;<i> The same signatories could be used for the DLCs, and even if the update transaction changes, you can reanchor the DLC subcontracts with `SIGHASH_NOINPUT`.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; Code speaks louder than words.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Of course. :)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, so feel free to ignore whatever I say, since I have not coded for a while.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.
</I>&gt;&gt;&gt;<i> &gt; It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.
</I>&gt;&gt;&gt;<i> &gt; In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks before the absolute timelock expires.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Restrictions regarding when to publish could be managed at a higher
</I>&gt;&gt;&gt;<i> level. What Fulgurite is trying to solve is how to manage the state
</I>&gt;&gt;&gt;<i> negotiation rather than the high-level logic about when exactly to
</I>&gt;&gt;&gt;<i> publish commitment txs. Maybe we should slightly alter the mechanics
</I>&gt;&gt;&gt;<i> for how HTLC expiry works in-channel vs on-chain for this problem?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> At minimum the lower-level system would have to alert the higher-level system that a time-sensitive contract needs to collapse the Fulgrite system or else it would not be possible to enforce the timelock.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Since contracts inside a multiparticipant updatable system can be cancelled by the agreement of all participants, I suppose the higher layer can decide to demand an update that the timelock be followed within the multiparticipant updatable system.
</I>&gt;&gt;<i> But the upper layer needs to be informed of the latest time that the contract can be enforced onchain.
</I>&gt;&gt;<i> Your alternative is that the upper layer needs to know whether the lower layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can argue is a layering violation.
</I>&gt;&gt;<i> Further the exact specs (how many blocks do all participants agree is reasonable for the CSV requirement?) would vary.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.
</I>&gt;&gt;<i> Higher layers can simply be concerned about what contracts it wants to enter into.
</I>&gt;&gt;<i> The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.
</I>&gt;&gt;<i> The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Regards,
</I>&gt;&gt;<i> ZmnSCPxj
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ------------------------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Message: 3
</I>&gt;&gt;<i> Date: Thu, 6 Dec 2018 20:41:30 -0500
</I>&gt;&gt;<i> From: Trey Del Bonis &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">j.delbonis.3 at gmail.com</A>&gt;
</I>&gt;&gt;<i> To: <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i> Subject: [Lightning-dev] Fwd: Fulgurite: ideas for making a more
</I>&gt;&gt;<i>         flexible Lightning Network protocol
</I>&gt;&gt;<i> Message-ID:
</I>&gt;&gt;<i>         &lt;CAFUsdzpDzwQF=n5zVWOezN35Ng0htw=<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">CWbyeNaoryqxmOp1skA at mail.gmail.com</A>&gt;
</I>&gt;&gt;<i> Content-Type: text/plain; charset=&quot;UTF-8&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (Resubmitted because it was accidentally auto-discarded.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hello list and ZmnSCPxj,
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Non-participants cannot safely (non-custodially) use any such &quot;shared-ownership update system&quot; and any subsystems within it since they have no power to refuse to sign off an invalid state transition.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not trying to solve that problem.  Although I don't foresee it
</I>&gt;&gt;<i> being difficult to allow participants to cooperatively join channels
</I>&gt;&gt;<i> in a procedure like a splice, the output would be to a (n+1)-of-(n+1)
</I>&gt;&gt;<i> multisig address (or alternatively, -1 for leaving channels).
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>*However*, I wonder if Fulgurite adds more complexity than necessary.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I believe that the step up in complexity is justified given the change
</I>&gt;&gt;<i> in how we express information in channels.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>2-party shared-ownership update systems (&quot;channels&quot;) are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You're right.  The point of bringing multiparty channels into this
</I>&gt;&gt;<i> discussion was to say &quot;here's how we'd do it in Fulgurite if somebody
</I>&gt;&gt;<i> wanted to&quot;, it just requires a lot more coordination that not every
</I>&gt;&gt;<i> environment would be able to have.  Points of failure, etc.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That's true.  My construction should still be able to do
</I>&gt;&gt;<i> Burchert-Decker-Wattenhofer exactly as described with a little work
</I>&gt;&gt;<i> using the same primitives, although I haven't gone out of my way yet
</I>&gt;&gt;<i> to formulate how to do it yet since it's a little auxiliary to what
</I>&gt;&gt;<i> we've been wanting to do with subchannels here at the DCI.  One thing
</I>&gt;&gt;<i> we've talked about is if you and your counterparty want to route
</I>&gt;&gt;<i> payments through each other but also want to enter into discreet log
</I>&gt;&gt;<i> contracts, it might make sense to set up a subchannel for each purpose
</I>&gt;&gt;<i> so you don't have to re-sign for all the potential outcomes for the
</I>&gt;&gt;<i> DLCs (slow!) every time you add/remove an HTLC.  Only the routing
</I>&gt;&gt;<i> (sub)channel would be announced to the routing network.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Code speaks louder than words.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Of course. :)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.
</I>&gt;&gt;&gt;<i>It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.
</I>&gt;&gt;&gt;<i>In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Restrictions regarding when to publish could be managed at a higher
</I>&gt;&gt;<i> level.  What Fulgurite is trying to solve is how to manage the state
</I>&gt;&gt;<i> negotiation rather than the high-level logic about when exactly to
</I>&gt;&gt;<i> publish commitment txs.  Maybe we should slightly alter the mechanics
</I>&gt;&gt;<i> for how HTLC expiry works in-channel vs on-chain for this problem?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'll admit that there's still a few unknowns that I have yet to think
</I>&gt;&gt;<i> about and figure out how to deal with, like this.  But it's my
</I>&gt;&gt;<i> intuition that there's probably a simple solution just by making sure
</I>&gt;&gt;<i> the right checks happen in the right places.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - Trey Del Bonis
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Thu, Dec 6, 2018 at 6:20 AM ZmnSCPxj &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Good morning list, and also Trey,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I confirmed that Trey accidentally replied only to me, but intended to reply to the list.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt; Burchert-Decker-Wattenhofer channel factories are essentially multiparty (&gt; 2 participants) &quot;channels&quot; (&quot;offchain updateable cryptocurrency systems&quot;) with multiple &quot;child&quot; 2-party channels. In general though having multiple channels between the same 2 participants is not as valuable (which is why Burchert-Decker-Wattenhofer only has two levels in the hierarchy, and why the parent level is multiparty while the child level is 2-party).
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Where I was going with the paper is to figure out some of the details
</I>&gt;&gt;&gt;<i> &gt; surrounding how to actually implement the protocols described by the
</I>&gt;&gt;&gt;<i> &gt; more formal reasearch in the area and leave space in the design for
</I>&gt;&gt;&gt;<i> &gt; other protocols that have yet to be designed to be implemented without
</I>&gt;&gt;&gt;<i> &gt; having to do a large overhaul of the protocol. If we want to go and
</I>&gt;&gt;&gt;<i> &gt; do Burchert-Decker-Wattenhofer-style channel factories we just have to
</I>&gt;&gt;&gt;<i> &gt; describe it in terms of manipulating the Fulgurite state graph,
</I>&gt;&gt;&gt;<i> &gt; without everyone in the channel actually having to understand
</I>&gt;&gt;&gt;<i> &gt; Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are
</I>&gt;&gt;&gt;<i> &gt; expected to have only a subset of the participants of their parents.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In effect, Fulgurite simply generalizes Lightning shared-ownership update systems (&quot;channels&quot;).
</I>&gt;&gt;&gt;<i> The insight effectively is that:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1.  Any contract of interest to participants of a single &quot;shared-ownership update system&quot; can be done, as long as the contract is enforceable onchain.
</I>&gt;&gt;&gt;<i> 2.  The &quot;shared-ownership update system&quot; itself is a contract that is enforceable onchain.
</I>&gt;&gt;&gt;<i> 3.  Therefore, a &quot;shared-ownership update system&quot; can contain &quot;shared-ownership update systems&quot; of interest to its participants.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So &quot;subsystems&quot; here can have the same set of participants, or a subset of participants.
</I>&gt;&gt;&gt;<i> Non-participants cannot safely (non-custodially) use any such &quot;shared-ownership update system&quot; and any subsystems within it since they have no power to refuse to sign off an invalid state transition.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> *However*, I wonder if Fulgurite adds more complexity than necessary.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 2-party shared-ownership update systems (&quot;channels&quot;) are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt; Of note is that the existing update protocols can carry almost any Bitcoin-enforceable contract, including the same contracts used to enforce them. This is what allows update protocols to &quot;nest&quot; as in Burchert-Decker-Wattenhofer (or your concept of &quot;parent&quot; and &quot;child&quot; channels).
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Of course. But unless I'm mistaken I haven't seen any practical
</I>&gt;&gt;&gt;<i> &gt; implentations of it yet, which is what I'm attempting to do. I know I
</I>&gt;&gt;&gt;<i> &gt; won't get much adoption without BOLT support, but that's not a goal in
</I>&gt;&gt;&gt;<i> &gt; the short term at least.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Code speaks louder than words.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt; There are some important details like the fact that Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on their transported contracts, and most contracts cannot be transported across systems (HTLCs can but with longer timelocks for each step).
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Building transactions might not be able to be 100% transparent to the
</I>&gt;&gt;&gt;<i> &gt; partition behavior, but I don't really think that's a major
</I>&gt;&gt;&gt;<i> &gt; restriction we need to worry about right now. Partitions talk about
</I>&gt;&gt;&gt;<i> &gt; their on-chain representation at a relatively high level (see the
</I>&gt;&gt;&gt;<i> &gt; `Contract` enum in the `core` crate) and the transaction builder (yet
</I>&gt;&gt;&gt;<i> &gt; to be written) figures out how to implement that.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I believe it *is* important to worry about it right now.
</I>&gt;&gt;&gt;<i> The only objection I have to Decker-Russell-Osuntokun is that it adds an additional CSV requirement to transported contracts.
</I>&gt;&gt;&gt;<i> Otherwise it is strictly superior to Poon-Dryja.
</I>&gt;&gt;&gt;<i> CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.
</I>&gt;&gt;&gt;<i> It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.
</I>&gt;&gt;&gt;<i> In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Basically:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1.  Any absolute timelocked contract implies a timeout for the lifetime of the Fulgurite system/channel it is in.
</I>&gt;&gt;&gt;<i> 2.  The contract must be fulfilled via a non-timelocked branch before that lifetime.
</I>&gt;&gt;&gt;<i> 3.  If not fulfilled via a non-timelocked branch, the Fulgurite system must collapse onchain 1 block before the lifetime.
</I>&gt;&gt;&gt;<i> 4.  If the Fulgurite system is based on Decker-Wattenhofer or Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the lifetime, where N is the CSV timeout for the update system used.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Regards,
</I>&gt;&gt;&gt;<i> ZmnSCPxj
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ------------------------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Lightning-dev mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> End of Lightning-dev Digest, Vol 40, Issue 8
</I>&gt;&gt;<i> ********************************************
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181208/a668a67b/attachment-0001.html">http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181208/a668a67b/attachment-0001.html</A>&gt;
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001729.html">[Lightning-dev] OpenCAP alias integrations with invoices/destination
</A></li>
	<LI>Next message: <A HREF="001736.html">[Lightning-dev] [META] Organization of 1.1 Spec Effort
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1731">[ date ]</a>
              <a href="thread.html#1731">[ thread ]</a>
              <a href="subject.html#1731">[ subject ]</a>
              <a href="author.html#1731">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>

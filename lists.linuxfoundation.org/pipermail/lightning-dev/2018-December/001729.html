<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] OpenCAP alias integrations with invoices/destination
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-December/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20OpenCAP%20alias%20integrations%20with%20invoices/destination&In-Reply-To=%3CCABsg%2BrG4tcEuUe-DvL0i0rAzsZjPM_RwMGznETVhJvRXLuXwTA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001728.html">
   <LINK REL="Next"  HREF="001731.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] OpenCAP alias integrations with invoices/destination</H1>
    <B>Lane Wagner</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20OpenCAP%20alias%20integrations%20with%20invoices/destination&In-Reply-To=%3CCABsg%2BrG4tcEuUe-DvL0i0rAzsZjPM_RwMGznETVhJvRXLuXwTA%40mail.gmail.com%3E"
       TITLE="[Lightning-dev] OpenCAP alias integrations with invoices/destination">lane.c.wagner at gmail.com
       </A><BR>
    <I>Fri Dec  7 13:14:20 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="001728.html">[Lightning-dev] Fwd: Fulgurite: ideas for making a more flexible Lightning Network protocol
</A></li>
        <LI>Next message: <A HREF="001731.html">[Lightning-dev] OpenCAP alias integrations with	invoices/destination
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1729">[ date ]</a>
              <a href="thread.html#1729">[ thread ]</a>
              <a href="subject.html#1729">[ subject ]</a>
              <a href="author.html#1729">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Im working on a protocol that allows users to host crypto public addresses,
using a standard DNS lookup schema. It offers some advantages over
OpenAlias and I'm hopeful that we will see actual adoption.

I want users to be able to post lightning invoices as well, although I know
this is difficult because typically invoices must be generated uniquely for
each payment. I was thinking maybe posting a destination could be good, so
that people can open channels with you, but then people with existing
channels still couldnt send to you.

Does anyone have thoughts on this?

Protocol: <A HREF="https://GitHub.com/OpenCAP/protocol">https://GitHub.com/OpenCAP/protocol</A> (link to discord for
discussion is there)

Implementation: <A HREF="https://ogdolo.com">https://ogdolo.com</A>

Open source implementation: <A HREF="https://GitHub.com/OpenCAP/go-server">https://GitHub.com/OpenCAP/go-server</A>


On Fri, Dec 7, 2018, 5:00 AM &lt;
<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-request at lists.linuxfoundation.org</A> wrote:

&gt;<i> Send Lightning-dev mailing list submissions to
</I>&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;<i>
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-request at lists.linuxfoundation.org</A>
</I>&gt;<i>
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i>         <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev-owner at lists.linuxfoundation.org</A>
</I>&gt;<i>
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of Lightning-dev digest...&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Today's Topics:
</I>&gt;<i>
</I>&gt;<i>    1. Re: Reason for having HMACs in Sphinx (Christian Decker)
</I>&gt;<i>    2. Re: Fulgurite: ideas for making a more flexible   Lightning
</I>&gt;<i>       Network protocol (ZmnSCPxj)
</I>&gt;<i>    3. Fwd: Fulgurite: ideas for making a more flexible Lightning
</I>&gt;<i>       Network protocol (Trey Del Bonis)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Thu, 06 Dec 2018 16:24:20 +0100
</I>&gt;<i> From: Christian Decker &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">decker.christian at gmail.com</A>&gt;
</I>&gt;<i> To: Corn? Plooy &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">corne at bitonic.nl</A>&gt;, ZmnSCPxj    &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt;
</I>&gt;<i> Cc: &quot;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&quot;
</I>&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;<i> Subject: Re: [Lightning-dev] Reason for having HMACs in Sphinx
</I>&gt;<i> Message-ID: &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">875zw6adaz.fsf at gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=utf-8
</I>&gt;<i>
</I>&gt;<i> Corn? Plooy &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">corne at bitonic.nl</A>&gt; writes:
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; The total_decorrelation_secrets serves as the payer-generated shared
</I>&gt;<i> &gt;&gt; secret between payer and payee.  B cannot learn this, and thus cannot
</I>&gt;<i> &gt;&gt; fake its own secret.  Even if it instead offers ((I + K[A]) + k[z] *
</I>&gt;<i> &gt;&gt; G) for a new secret k[z], it cannot know how to change
</I>&gt;<i> &gt;&gt; total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; The way things are now, the ephemeral key generation and the payment
</I>&gt;<i> &gt; hash/preimage generation are completely unrelated. This is what allows
</I>&gt;<i> &gt; an attacker to use the same payment hash, and use his own ephemeral key
</I>&gt;<i> &gt; pair to create a new onion packet around it.
</I>&gt;<i>
</I>&gt;<i> That is correct, one is generated by the recipient (secret and preimage)
</I>&gt;<i> and the other one is generated by the sender (ephemeral key). Mixing the
</I>&gt;<i> two seems very unwise, since the sender has very little control over
</I>&gt;<i> what the effective ephemeral key that is going to be used for the last
</I>&gt;<i> hop. This is the same issue that we have with rendez-vous routing, i.e.,
</I>&gt;<i> that if we require the ephemeral key to be something specific at a given
</I>&gt;<i> node we'd be breaking the hardness assumption of for the ephemeral key
</I>&gt;<i> rotation.
</I>&gt;<i>
</I>&gt;<i> &gt; Primarily, path decorrelation replaces the payment hash/preimage part.
</I>&gt;<i> &gt; Maybe I still don't understand something, but if that's the only thing
</I>&gt;<i> &gt; (without changing the ephemeral key / onion shared secret generation),
</I>&gt;<i> &gt; attacking the direct neighbor should still work; in your case, B would
</I>&gt;<i> &gt; still offer ((I + K[A]) + K[B]) to C, with an onion packet B created
</I>&gt;<i> &gt; himself. I'm not familiar enough with the path correlation to understand
</I>&gt;<i> &gt; what happens after step 6, but for C it looks the same, so she should do
</I>&gt;<i> &gt; the same.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I do see that, if you couple the &quot;H&quot;TLC payment secret generation to the
</I>&gt;<i> &gt; onion shared secret generation, you can make the attack impossible. Do I
</I>&gt;<i> &gt; understand correctly that this is the idea? After all, C still needs to
</I>&gt;<i> &gt; receive k somehow; my crypto math isn't that good, but my intuitive
</I>&gt;<i> &gt; guess is that i + k is the secret that allows C to claim funds locked in
</I>&gt;<i> &gt; ((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A
</I>&gt;<i> &gt; to C through some mechanism that replaces the current ephemeral key
</I>&gt;<i> &gt; system, then I understand what you're at.
</I>&gt;<i>
</I>&gt;<i> I can't quite follow where we would be mixing in the ephemeral key here,
</I>&gt;<i> could you elaborate on that?
</I>&gt;<i>
</I>&gt;<i> &gt; Assuming this is the case, it's pretty neat. I do wonder how it
</I>&gt;<i> &gt; interacts with rendezvous routing. If the sender and receiver each
</I>&gt;<i> &gt; create the k[..] values for their own part of the route, can the
</I>&gt;<i> &gt; receiver-generated onion packet still use points of the form ((I + K[A])
</I>&gt;<i> &gt; + K[B]), including K[..] values related to the sender side? I need to
</I>&gt;<i> &gt; dig deeper into this path decorrelation idea.
</I>&gt;<i>
</I>&gt;<i> Since we have very little control over what ephemeral key will actually
</I>&gt;<i> be presented to the last hop if we have a multi-hop route, we can't
</I>&gt;<i> really hide any information in the ephemeral key itself. What we could
</I>&gt;<i> do is change the way the last hop generates the shared secret from it,
</I>&gt;<i> i.e., have a last hop mode and a forwarding hop mode, and mix in the
</I>&gt;<i> payment secret somehow, but I can't think of a good way to do that, and
</I>&gt;<i> it seems contorted. Let's just have the sender prove knowledge of the
</I>&gt;<i> original invoice by adding a TLV field with a shared secret from the
</I>&gt;<i> invoice instead.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Christian
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Thu, 06 Dec 2018 23:22:57 +0000
</I>&gt;<i> From: ZmnSCPxj &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt;
</I>&gt;<i> To: Trey Del Bonis &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">j.delbonis.3 at gmail.com</A>&gt;
</I>&gt;<i> Cc: &quot;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&quot;
</I>&gt;<i>         &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>&gt;
</I>&gt;<i> Subject: Re: [Lightning-dev] Fulgurite: ideas for making a more
</I>&gt;<i>         flexible        Lightning Network protocol
</I>&gt;<i> Message-ID:
</I>&gt;<i>
</I>&gt;<i> &lt;qyU2TN0y6zXLjNtCrgEwlNjJh9WvMEnHLGoLEnS4c_9OXh8hyEn-gxnAwloz2cjUT1aedkonILtSJingtEucQYQiT6Y0wUgwZWkRmSKK_FA=@
</I>&gt;<i> protonmail.com&gt;
</I>&gt;<i>
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i>
</I>&gt;<i> Good morning Trey,
</I>&gt;<i> &gt; One thing
</I>&gt;<i> &gt; we've talked about is if you and your counterparty want to route
</I>&gt;<i> &gt; payments through each other but also want to enter into discreet log
</I>&gt;<i> &gt; contracts, it might make sense to set up a subchannel for each purpose
</I>&gt;<i> &gt; so you don't have to re-sign for all the potential outcomes for the
</I>&gt;<i> &gt; DLCs (slow!) every time you add/remove an HTLC. Only the routing
</I>&gt;<i> &gt; (sub)channel would be announced to the routing network.
</I>&gt;<i>
</I>&gt;<i> Of note, the routing gossip is not trust-based.
</I>&gt;<i> Instead, part of the routing gossip is the block and transaction and
</I>&gt;<i> output on which the channel is anchored onchain.
</I>&gt;<i> Nodes check if the specified txo is unspent, and matches the purported
</I>&gt;<i> capacity of the channel.
</I>&gt;<i> Once a channel outpoint is spent, nodes automatically remove it from their
</I>&gt;<i> maps.
</I>&gt;<i>
</I>&gt;<i> In a world with Burchert-Decker-Wattenhofer factories, the factory would
</I>&gt;<i> have an onchain txo.
</I>&gt;<i> Gossip would contain all the channels in the factory, and would be signed
</I>&gt;<i> by the same signatories as the onchain txo.
</I>&gt;<i> Nodes would check that the channels purported to be contained in the
</I>&gt;<i> factory sum up to the value of this txo.
</I>&gt;<i>
</I>&gt;<i> I suppose that could be relaxed, so that the channels purported to be in
</I>&gt;<i> the factory would sum up to less than or equal to the value of the channel
</I>&gt;<i> factory txo instead.
</I>&gt;<i> This would allow a Fulgurite system to allocate only part of its funds to
</I>&gt;<i> Lightning-visible routing nodes.
</I>&gt;<i>
</I>&gt;<i> It strikes me that the issue of re-signing the DLC subcontracts could be
</I>&gt;<i> avoided if you use `SIGHASH_NOINPUT`.
</I>&gt;<i> The same signatories could be used for the DLCs, and even if the update
</I>&gt;<i> transaction changes, you can reanchor the DLC subcontracts with
</I>&gt;<i> `SIGHASH_NOINPUT`.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; Code speaks louder than words.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Of course. :)
</I>&gt;<i>
</I>&gt;<i> Yes, so feel free to ignore whatever I say, since I have not coded for a
</I>&gt;<i> while.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; CSV requirements are a time-based requirement that affect the behavior
</I>&gt;<i> of absolute timelocks used by HTLCs.
</I>&gt;<i> &gt; &gt; It is better to admit this earlier than later, since it becomes
</I>&gt;<i> possible as an attack point if you do not take care to pay attention to the
</I>&gt;<i> CSV requirement.
</I>&gt;<i> &gt; &gt; In particular, timelocked contracts need to be published onchain
</I>&gt;<i> before the timeout expires, and a N-block CSV requirement then means you
</I>&gt;<i> have to publish onchain N+1 blocks before the absolute timelock expires.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Restrictions regarding when to publish could be managed at a higher
</I>&gt;<i> &gt; level. What Fulgurite is trying to solve is how to manage the state
</I>&gt;<i> &gt; negotiation rather than the high-level logic about when exactly to
</I>&gt;<i> &gt; publish commitment txs. Maybe we should slightly alter the mechanics
</I>&gt;<i> &gt; for how HTLC expiry works in-channel vs on-chain for this problem?
</I>&gt;<i>
</I>&gt;<i> At minimum the lower-level system would have to alert the higher-level
</I>&gt;<i> system that a time-sensitive contract needs to collapse the Fulgrite system
</I>&gt;<i> or else it would not be possible to enforce the timelock.
</I>&gt;<i>
</I>&gt;<i> Since contracts inside a multiparticipant updatable system can be
</I>&gt;<i> cancelled by the agreement of all participants, I suppose the higher layer
</I>&gt;<i> can decide to demand an update that the timelock be followed within the
</I>&gt;<i> multiparticipant updatable system.
</I>&gt;<i> But the upper layer needs to be informed of the latest time that the
</I>&gt;<i> contract can be enforced onchain.
</I>&gt;<i> Your alternative is that the upper layer needs to know whether the lower
</I>&gt;<i> layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV
</I>&gt;<i> requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can
</I>&gt;<i> argue is a layering violation.
</I>&gt;<i> Further the exact specs (how many blocks do all participants agree is
</I>&gt;<i> reasonable for the CSV requirement?) would vary.
</I>&gt;<i>
</I>&gt;<i> So it seems to me better to move time-sensitivity to Fulgurite than to
</I>&gt;<i> higher layers.
</I>&gt;<i> Higher layers can simply be concerned about what contracts it wants to
</I>&gt;<i> enter into.
</I>&gt;<i> The higher layer informs the Fulgurite layer of the shortest absolute
</I>&gt;<i> timelock in each contract it enters into.
</I>&gt;<i> The Fulgurite layer then returns to the higher layer the latest
</I>&gt;<i> blockheight at which it can still safely collapse the Fulgurite system, or
</I>&gt;<i> an error that the absolute timelock is too near and is already not
</I>&gt;<i> enforceable at the Fulgurite layer.
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> ZmnSCPxj
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 3
</I>&gt;<i> Date: Thu, 6 Dec 2018 20:41:30 -0500
</I>&gt;<i> From: Trey Del Bonis &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">j.delbonis.3 at gmail.com</A>&gt;
</I>&gt;<i> To: <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;<i> Subject: [Lightning-dev] Fwd: Fulgurite: ideas for making a more
</I>&gt;<i>         flexible Lightning Network protocol
</I>&gt;<i> Message-ID:
</I>&gt;<i>         &lt;CAFUsdzpDzwQF=n5zVWOezN35Ng0htw=
</I>&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">CWbyeNaoryqxmOp1skA at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;UTF-8&quot;
</I>&gt;<i>
</I>&gt;<i> (Resubmitted because it was accidentally auto-discarded.)
</I>&gt;<i>
</I>&gt;<i> Hello list and ZmnSCPxj,
</I>&gt;<i>
</I>&gt;<i> &gt;Non-participants cannot safely (non-custodially) use any such
</I>&gt;<i> &quot;shared-ownership update system&quot; and any subsystems within it since they
</I>&gt;<i> have no power to refuse to sign off an invalid state transition.
</I>&gt;<i>
</I>&gt;<i> I'm not trying to solve that problem.  Although I don't foresee it
</I>&gt;<i> being difficult to allow participants to cooperatively join channels
</I>&gt;<i> in a procedure like a splice, the output would be to a (n+1)-of-(n+1)
</I>&gt;<i> multisig address (or alternatively, -1 for leaving channels).
</I>&gt;<i>
</I>&gt;<i> &gt;*However*, I wonder if Fulgurite adds more complexity than necessary.
</I>&gt;<i>
</I>&gt;<i> I believe that the step up in complexity is justified given the change
</I>&gt;<i> in how we express information in channels.
</I>&gt;<i>
</I>&gt;<i> &gt;2-party shared-ownership update systems (&quot;channels&quot;) are best, since
</I>&gt;<i> everyone has to sign.  Fewer participants means fewer points of failure.
</I>&gt;<i> Larger participant sets mean it is more likely somebody will be absent when
</I>&gt;<i> any one of them wants to update the shared-ownership update system.
</I>&gt;<i>
</I>&gt;<i> You're right.  The point of bringing multiparty channels into this
</I>&gt;<i> discussion was to say &quot;here's how we'd do it in Fulgurite if somebody
</I>&gt;<i> wanted to&quot;, it just requires a lot more coordination that not every
</I>&gt;<i> environment would be able to have.  Points of failure, etc.
</I>&gt;<i>
</I>&gt;<i> &gt;Burchert-Decker-Wattenhofer channel factories have the advantage that
</I>&gt;<i> once the channels within the factory have been set up, participants can
</I>&gt;<i> then be absent, and only their channels are affected.
</I>&gt;<i>
</I>&gt;<i> That's true.  My construction should still be able to do
</I>&gt;<i> Burchert-Decker-Wattenhofer exactly as described with a little work
</I>&gt;<i> using the same primitives, although I haven't gone out of my way yet
</I>&gt;<i> to formulate how to do it yet since it's a little auxiliary to what
</I>&gt;<i> we've been wanting to do with subchannels here at the DCI.  One thing
</I>&gt;<i> we've talked about is if you and your counterparty want to route
</I>&gt;<i> payments through each other but also want to enter into discreet log
</I>&gt;<i> contracts, it might make sense to set up a subchannel for each purpose
</I>&gt;<i> so you don't have to re-sign for all the potential outcomes for the
</I>&gt;<i> DLCs (slow!) every time you add/remove an HTLC.  Only the routing
</I>&gt;<i> (sub)channel would be announced to the routing network.
</I>&gt;<i>
</I>&gt;<i> &gt;Code speaks louder than words.
</I>&gt;<i>
</I>&gt;<i> Of course. :)
</I>&gt;<i>
</I>&gt;<i> &gt;CSV requirements are a time-based requirement that affect the behavior of
</I>&gt;<i> absolute timelocks used by HTLCs.
</I>&gt;<i> &gt;It is better to admit this earlier than later, since it becomes possible
</I>&gt;<i> as an attack point if you do not take care to pay attention to the CSV
</I>&gt;<i> requirement.
</I>&gt;<i> &gt;In particular, timelocked contracts need to be published onchain before
</I>&gt;<i> the timeout expires, and a N-block CSV requirement then means you have to
</I>&gt;<i> publish onchain N+1 blocks *before* the absolute timelock expires.
</I>&gt;<i>
</I>&gt;<i> Restrictions regarding when to publish could be managed at a higher
</I>&gt;<i> level.  What Fulgurite is trying to solve is how to manage the state
</I>&gt;<i> negotiation rather than the high-level logic about when exactly to
</I>&gt;<i> publish commitment txs.  Maybe we should slightly alter the mechanics
</I>&gt;<i> for how HTLC expiry works in-channel vs on-chain for this problem?
</I>&gt;<i>
</I>&gt;<i> I'll admit that there's still a few unknowns that I have yet to think
</I>&gt;<i> about and figure out how to deal with, like this.  But it's my
</I>&gt;<i> intuition that there's probably a simple solution just by making sure
</I>&gt;<i> the right checks happen in the right places.
</I>&gt;<i>
</I>&gt;<i> - Trey Del Bonis
</I>&gt;<i>
</I>&gt;<i> On Thu, Dec 6, 2018 at 6:20 AM ZmnSCPxj &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">ZmnSCPxj at protonmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Good morning list, and also Trey,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I confirmed that Trey accidentally replied only to me, but intended to
</I>&gt;<i> reply to the list.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; &gt; Burchert-Decker-Wattenhofer channel factories are essentially
</I>&gt;<i> multiparty (&gt; 2 participants) &quot;channels&quot; (&quot;offchain updateable
</I>&gt;<i> cryptocurrency systems&quot;) with multiple &quot;child&quot; 2-party channels. In general
</I>&gt;<i> though having multiple channels between the same 2 participants is not as
</I>&gt;<i> valuable (which is why Burchert-Decker-Wattenhofer only has two levels in
</I>&gt;<i> the hierarchy, and why the parent level is multiparty while the child level
</I>&gt;<i> is 2-party).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Where I was going with the paper is to figure out some of the details
</I>&gt;<i> &gt; &gt; surrounding how to actually implement the protocols described by the
</I>&gt;<i> &gt; &gt; more formal reasearch in the area and leave space in the design for
</I>&gt;<i> &gt; &gt; other protocols that have yet to be designed to be implemented without
</I>&gt;<i> &gt; &gt; having to do a large overhaul of the protocol. If we want to go and
</I>&gt;<i> &gt; &gt; do Burchert-Decker-Wattenhofer-style channel factories we just have to
</I>&gt;<i> &gt; &gt; describe it in terms of manipulating the Fulgurite state graph,
</I>&gt;<i> &gt; &gt; without everyone in the channel actually having to understand
</I>&gt;<i> &gt; &gt; Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are
</I>&gt;<i> &gt; &gt; expected to have only a subset of the participants of their parents.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In effect, Fulgurite simply generalizes Lightning shared-ownership
</I>&gt;<i> update systems (&quot;channels&quot;).
</I>&gt;<i> &gt; The insight effectively is that:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1.  Any contract of interest to participants of a single
</I>&gt;<i> &quot;shared-ownership update system&quot; can be done, as long as the contract is
</I>&gt;<i> enforceable onchain.
</I>&gt;<i> &gt; 2.  The &quot;shared-ownership update system&quot; itself is a contract that is
</I>&gt;<i> enforceable onchain.
</I>&gt;<i> &gt; 3.  Therefore, a &quot;shared-ownership update system&quot; can contain
</I>&gt;<i> &quot;shared-ownership update systems&quot; of interest to its participants.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So &quot;subsystems&quot; here can have the same set of participants, or a subset
</I>&gt;<i> of participants.
</I>&gt;<i> &gt; Non-participants cannot safely (non-custodially) use any such
</I>&gt;<i> &quot;shared-ownership update system&quot; and any subsystems within it since they
</I>&gt;<i> have no power to refuse to sign off an invalid state transition.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; *However*, I wonder if Fulgurite adds more complexity than necessary.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2-party shared-ownership update systems (&quot;channels&quot;) are best, since
</I>&gt;<i> everyone has to sign.  Fewer participants means fewer points of failure.
</I>&gt;<i> Larger participant sets mean it is more likely somebody will be absent when
</I>&gt;<i> any one of them wants to update the shared-ownership update system.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Burchert-Decker-Wattenhofer channel factories have the advantage that
</I>&gt;<i> once the channels within the factory have been set up, participants can
</I>&gt;<i> then be absent, and only their channels are affected.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; &gt; Of note is that the existing update protocols can carry almost any
</I>&gt;<i> Bitcoin-enforceable contract, including the same contracts used to enforce
</I>&gt;<i> them. This is what allows update protocols to &quot;nest&quot; as in
</I>&gt;<i> Burchert-Decker-Wattenhofer (or your concept of &quot;parent&quot; and &quot;child&quot;
</I>&gt;<i> channels).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Of course. But unless I'm mistaken I haven't seen any practical
</I>&gt;<i> &gt; &gt; implentations of it yet, which is what I'm attempting to do. I know I
</I>&gt;<i> &gt; &gt; won't get much adoption without BOLT support, but that's not a goal in
</I>&gt;<i> &gt; &gt; the short term at least.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Code speaks louder than words.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; &gt; There are some important details like the fact that
</I>&gt;<i> Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on
</I>&gt;<i> their transported contracts, and most contracts cannot be transported
</I>&gt;<i> across systems (HTLCs can but with longer timelocks for each step).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Building transactions might not be able to be 100% transparent to the
</I>&gt;<i> &gt; &gt; partition behavior, but I don't really think that's a major
</I>&gt;<i> &gt; &gt; restriction we need to worry about right now. Partitions talk about
</I>&gt;<i> &gt; &gt; their on-chain representation at a relatively high level (see the
</I>&gt;<i> &gt; &gt; `Contract` enum in the `core` crate) and the transaction builder (yet
</I>&gt;<i> &gt; &gt; to be written) figures out how to implement that.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I believe it *is* important to worry about it right now.
</I>&gt;<i> &gt; The only objection I have to Decker-Russell-Osuntokun is that it adds an
</I>&gt;<i> additional CSV requirement to transported contracts.
</I>&gt;<i> &gt; Otherwise it is strictly superior to Poon-Dryja.
</I>&gt;<i> &gt; CSV requirements are a time-based requirement that affect the behavior
</I>&gt;<i> of absolute timelocks used by HTLCs.
</I>&gt;<i> &gt; It is better to admit this earlier than later, since it becomes possible
</I>&gt;<i> as an attack point if you do not take care to pay attention to the CSV
</I>&gt;<i> requirement.
</I>&gt;<i> &gt; In particular, timelocked contracts need to be published onchain before
</I>&gt;<i> the timeout expires, and a N-block CSV requirement then means you have to
</I>&gt;<i> publish onchain N+1 blocks *before* the absolute timelock expires.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Basically:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1.  Any absolute timelocked contract implies a timeout for the lifetime
</I>&gt;<i> of the Fulgurite system/channel it is in.
</I>&gt;<i> &gt; 2.  The contract must be fulfilled via a non-timelocked branch before
</I>&gt;<i> that lifetime.
</I>&gt;<i> &gt; 3.  If not fulfilled via a non-timelocked branch, the Fulgurite system
</I>&gt;<i> must collapse onchain 1 block before the lifetime.
</I>&gt;<i> &gt; 4.  If the Fulgurite system is based on Decker-Wattenhofer or
</I>&gt;<i> Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the
</I>&gt;<i> lifetime, where N is the CSV timeout for the update system used.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Regards,
</I>&gt;<i> &gt; ZmnSCPxj
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Lightning-dev mailing list
</I>&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">Lightning-dev at lists.linuxfoundation.org</A>
</I>&gt;<i> <A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> End of Lightning-dev Digest, Vol 40, Issue 8
</I>&gt;<i> ********************************************
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181207/bd4e84c8/attachment-0001.html">http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181207/bd4e84c8/attachment-0001.html</A>&gt;
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001728.html">[Lightning-dev] Fwd: Fulgurite: ideas for making a more flexible Lightning Network protocol
</A></li>
	<LI>Next message: <A HREF="001731.html">[Lightning-dev] OpenCAP alias integrations with	invoices/destination
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1729">[ date ]</a>
              <a href="thread.html#1729">[ thread ]</a>
              <a href="subject.html#1729">[ subject ]</a>
              <a href="author.html#1729">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>

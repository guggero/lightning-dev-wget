<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-June/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20LN%20Summit%202022%20Notes%20%26%20Summary/Commentary&In-Reply-To=%3CbsP9nbtOyTKv_ExfBw8qsrJMkNrindHzdcluUiXyqPjwShXtCf6KnIL3KJL_gF4z1NCrJWo-3xswKYveDfyonrcUkITy0JQwNhAiY5pzklg%3D%40protonmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003608.html">
   <LINK REL="Next"  HREF="003614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary</H1>
    <B>Michael Folkson</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20LN%20Summit%202022%20Notes%20%26%20Summary/Commentary&In-Reply-To=%3CbsP9nbtOyTKv_ExfBw8qsrJMkNrindHzdcluUiXyqPjwShXtCf6KnIL3KJL_gF4z1NCrJWo-3xswKYveDfyonrcUkITy0JQwNhAiY5pzklg%3D%40protonmail.com%3E"
       TITLE="[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary">michaelfolkson at protonmail.com
       </A><BR>
    <I>Tue Jun 21 11:54:27 UTC 2022</I>
    <P><UL>
        <LI>Previous message: <A HREF="003608.html">[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary
</A></li>
        <LI>Next message: <A HREF="003614.html">[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3615">[ date ]</a>
              <a href="thread.html#3615">[ thread ]</a>
              <a href="subject.html#3615">[ subject ]</a>
              <a href="author.html#3615">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the summary Laolu, very informative.

&gt;<i> One other cool topic that came up is the concept of leveraging recursive musig2 (so musig2 within musig2) to make channels even _more_ multi-sigy.
</I>
A minor point but terminology can get frustratingly sticky if it isn't agreed on early. Can we refer to it as nested&#8203;&#8203; MuSig2 going forward rather than recursive&#8203;&#8203; MuSig2? It is a more accurate description in my opinion and going through some old transcripts the MuSig2 authors [0] also refer it to nested MuSig2 (as far as I can make out).

Rene Pickhardt brought up the issue of latency with regards to nested/recursive MuSig2 (or nested FROST for threshold) on Bitcoin StackExchange [1]. Was this discussed at the LN Summit? I don't know how all the Lightning implementations treat latency currently (how long a channel counterparty has to provide a needed signature before moving to a unhappy path) but Rene's concern is delays in the regular completions of a nested MuSig2 or FROST scheme could make them unviable for the Lightning channel use case depending on the exact setup and physical location of signers etc.

MuSig2 obviously generates an aggregated Schnorr signature and so even nested MuSig2 require the Lightning protocol to recognize and verify Schnorr signatures which it currently doesn't right? So is the current thinking that Schnorr signatures will be supported first with a Schnorr 2-of-2 on the funding output (using OP_CHECKSIGADD and enabling the nested schemes) before potentially supporting non-nested MuSig2 between the channel counterparties on the funding output later? Or is this still in the process of being discussed?

[0]: <A HREF="https://btctranscripts.com/london-bitcoin-devs/2020-06-17-tim-ruffing-schnorr-multisig/">https://btctranscripts.com/london-bitcoin-devs/2020-06-17-tim-ruffing-schnorr-multisig/</A>
[1]: <A HREF="https://bitcoin.stackexchange.com/questions/114159/how-do-the-various-lightning-implementations-treat-latency-how-long-do-they-wai">https://bitcoin.stackexchange.com/questions/114159/how-do-the-various-lightning-implementations-treat-latency-how-long-do-they-wai</A>

--
Michael Folkson
Email: michaelfolkson at [protonmail.com](<A HREF="http://protonmail.com/">http://protonmail.com/</A>)
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

------- Original Message -------
On Wednesday, June 8th, 2022 at 03:38, Olaoluwa Osuntokun &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>&gt; wrote:

&gt;<i> Hi y'all,
</I>&gt;<i>
</I>&gt;<i> Last week nearly 30 (!) Lightning developers and researchers gathered in
</I>&gt;<i> Oakland, California for three day to discuss a number of matters related to
</I>&gt;<i> the current state and evolution of the protocol. This time around, we had
</I>&gt;<i> much better representation for all the major Lightning Node implementations
</I>&gt;<i> compared to the last LN Dev Summit (Zurich, Oct 2021).
</I>&gt;<i>
</I>&gt;<i> Similar to the prior LN Dev Summit, notes were kept throughout the day that
</I>&gt;<i> attempted on a best effort basis to capture the relevant discussions,
</I>&gt;<i> decisions, and new relevant research or follow up areas to circle back on.
</I>&gt;<i> Last time around, I sent out an email that summarized some key takeaways
</I>&gt;<i> (from my PoV) of the last multi-day dev summit [1]. What follows in this
</I>&gt;<i> email is a similar summary/recap of the three day summit. Just like last
</I>&gt;<i> time: if you attended and felt I missed out on a key point, or inadvertently
</I>&gt;<i> misrepresented a statement/idea, please feel free to reply, correcting or
</I>&gt;<i> adding additional detail.
</I>&gt;<i>
</I>&gt;<i> The meeting notes in full can be found here:
</I>&gt;<i> <A HREF="https://docs.google.com/document/d/1KHocBjlvg-XOFH5oG_HwWdvNBIvQgxwAok3ZQ6bnCW0/edit?usp=sharing">https://docs.google.com/document/d/1KHocBjlvg-XOFH5oG_HwWdvNBIvQgxwAok3ZQ6bnCW0/edit?usp=sharing</A>
</I>&gt;<i>
</I>&gt;<i> # Simple Taproot Channels
</I>&gt;<i>
</I>&gt;<i> During the last summit, Taproot was a major discussion topic as though the
</I>&gt;<i> soft fork had been deployed, we we're all still watching the &#129001; 's stack up
</I>&gt;<i> on the road to ultimately activation. Fast forward several months later and
</I>&gt;<i> Taproot has now been fully activated, with ecosystem starting to
</I>&gt;<i> progressively deploy more and more advanced systems/applications that take
</I>&gt;<i> advantage of the new features.
</I>&gt;<i>
</I>&gt;<i> One key deployment model that came out of the last LN Dev summit was the
</I>&gt;<i> concept of an iterative roadmap that progressively revamped the system to
</I>&gt;<i> use more taprooty features, instead of a &quot;big bang&quot; approach that would
</I>&gt;<i> attempt to package up as many things as possible into one larger update. At
</I>&gt;<i> a high level the iterative roadmap proposed that we unroll an existing
</I>&gt;<i> larger proposal [2] into more bite sized pieces that can be incrementally
</I>&gt;<i> reviewed, implemented, and ultimately deployed (see my post on the LN Dev
</I>&gt;<i> Summit 2021 for more details).
</I>&gt;<i>
</I>&gt;<i> ## Extension BOLTs
</I>&gt;<i>
</I>&gt;<i> Riiight before we started on the first day, I wrote up a minimal proposal
</I>&gt;<i> that attempted to tackle the first two items of the Taproot iterative
</I>&gt;<i> deployment schedule (musig2 funding outputs and simple tapscript mapping)
</I>&gt;<i> [3]. I called the proposal &quot;Simple Taproot Channels&quot; as it set out to do a
</I>&gt;<i> mechanical mapping of the current commitment and script structure to a more
</I>&gt;<i> taprooty domain. Rather than edit 4 or 5 different BOLTs with a series of
</I>&gt;<i> &quot;if this feature bit applies&quot; nested clauses, I instead opted to create a
</I>&gt;<i> new standalone &quot;extension bolt&quot; that defines _new_ behavior on top of the
</I>&gt;<i> existing BOLTs, referring to the BOLTs when necessary. The style of the
</I>&gt;<i> document was inspired by the &quot;proposals&quot; proposal (very meta), which was
</I>&gt;<i> popularized by cdecker and adopted by t-bast with his documents on
</I>&gt;<i> Trampoline and Blinded Paths.
</I>&gt;<i>
</I>&gt;<i> If the concept catches on, extension BOLTs provide us with a new way to
</I>&gt;<i> extend the spec: rather than insert everything in-line, we could instead
</I>&gt;<i> create new standalone documents for larger features. Having a single self
</I>&gt;<i> contained document makes the proposal easier to review, and also gives the
</I>&gt;<i> author more room to provide any background knowledge, primaries, and also
</I>&gt;<i> rationale. Overtime, as the new extensions become widespread (eg: taproot is
</I>&gt;<i> the default channel type), we can fold in the extensions back to the main
</I>&gt;<i> set of &quot;core&quot; BOLTs (or make new ones as relevant).
</I>&gt;<i>
</I>&gt;<i> Smaller changes to the spec like deprecating an old field or tightening up
</I>&gt;<i> some language will likely still follow the old approach of mutating the
</I>&gt;<i> existing BOLTs, but larger overhauls like the planned PTLC update may find
</I>&gt;<i> the extension BOLTs to be a better tool.
</I>&gt;<i>
</I>&gt;<i> ## Tapscript, Musig2, and Lightning
</I>&gt;<i>
</I>&gt;<i> As mentioned above the Simple Taproot Channels proposal does two main
</I>&gt;<i> things:
</I>&gt;<i> 1. Move the existing 2-of-2 p2wsh segwit v0 funding output to a _single
</I>&gt;<i> key_ p2tr output, with the single key actually being an aggregated musig2
</I>&gt;<i> key.
</I>&gt;<i>
</I>&gt;<i> 2. Map all our existing scripts to the tapscript domain, using the
</I>&gt;<i> internal key (keyspend path) for things like revocations, which an
</I>&gt;<i> potentially allow nodes to store less state for HTLCs.
</I>&gt;<i>
</I>&gt;<i> Of the two components #1 is by far the trickiest. Musig2 is a very elegant
</I>&gt;<i> protocol (not to mention the spec which y'all should totally check out) but
</I>&gt;<i> as the signatures aren't deterministic (like RFC 6979 [5]), both signers
</I>&gt;<i> need to &quot;protect themselves at all times&quot; to ensure they don't ever re-use
</I>&gt;<i> nonces, which can lead to a private key leak (!!).
</I>&gt;<i>
</I>&gt;<i> Rather than try to create some sort of psuedo-deterministic nonces scheme
</I>&gt;<i> (which maaybe works until the Blockstream Research team squints vaguely in
</I>&gt;<i> its direction), I opted to just make all nonces 100% ephemeral and tied to
</I>&gt;<i> the lifetime of a connection. Musig2 defines something called a public
</I>&gt;<i> nonces, which is actually two individual 33-byte nonces. This value needs to
</I>&gt;<i> be exchanged before signing can begin (but can be sent before sides know
</I>&gt;<i> they're aggregated keys). One important thing to note is that given that the
</I>&gt;<i> channels today have _asymmetric_ state, we actually need a _pair_ of public
</I>&gt;<i> nonces: one that I'll use to sign my commitment, and one I'll use to sign
</I>&gt;<i> yours. Lightning channels w/ symmetric state like eltoo can get by w/ only
</I>&gt;<i> exchange a single set of nonces, as there's only one message per state.
</I>&gt;<i>
</I>&gt;<i> Nonce exchange takes place in a few places:
</I>&gt;<i>
</I>&gt;<i> * During initial funding: I send my public nonce in the open_channel
</I>&gt;<i> message, you send yours in the accept_channel message. After this
</I>&gt;<i> exchange we can both generate signatures for the refund commitment
</I>&gt;<i> transactions.
</I>&gt;<i>
</I>&gt;<i> * After the channel is &quot;ready&quot; we send another set of nonces, so we can
</I>&gt;<i> sign the next state. This is similar to the existing revocation key
</I>&gt;<i> exchange: I need your next nonce/key before I can sign a new state.
</I>&gt;<i>
</I>&gt;<i> * Upon channel re-establishment a _new_ set of nonces is sent, as they're
</I>&gt;<i> 100% ephemeral. The current draft also requires that if you were
</I>&gt;<i> re-transmitting a sig, then you use the _new_ nonces to sign again, as
</I>&gt;<i> it's possible you went to retransmit but left off an expired/trimmed
</I>&gt;<i> HLTC (could lead to nonce re-use and also needing to remember nonces).
</I>&gt;<i>
</I>&gt;<i> * Each time I revoke my channel, I send to you a single nonce, my &quot;local
</I>&gt;<i> nonce&quot; (naming needs some work here), which lets you sign for a new
</I>&gt;<i> state.
</I>&gt;<i>
</I>&gt;<i> * Each time I send a new sig, I also send you another nonce, my &quot;remote&quot;
</I>&gt;<i> nonce&quot;, which
</I>&gt;<i>
</I>&gt;<i> * When I send a shutdown (co-op close) I send a single public nonce so we
</I>&gt;<i> can sign the next co-opc close offer.
</I>&gt;<i>
</I>&gt;<i> * When I send a closing_signed I send another nonce so once you send your
</I>&gt;<i> offer, we sign another set.
</I>&gt;<i>
</I>&gt;<i> The final flows aren't 100% yet finalized, as we'll need some
</I>&gt;<i> implementations drafted to make sure the nonce handling and script mapping
</I>&gt;<i> works out properly.
</I>&gt;<i>
</I>&gt;<i> ### Lightning Channels &amp; Recursive Musig2
</I>&gt;<i>
</I>&gt;<i> One other cool topic that came up is the concept of leveraging recursive
</I>&gt;<i> musig2 (so musig2 within musig2) to make channels even _more_ multi-sigy.
</I>&gt;<i> The benefit here is that Bob &amp; Carol can each have their individual keys
</I>&gt;<i> (which might actually be aggregated keys themselves) and make a channel w/
</I>&gt;<i> Alice, who only knows of them as Barol, and doesn't know there're actually
</I>&gt;<i> another pair of keys at play. This is _really_ cool as it allows node
</I>&gt;<i> operators, wallets, and lightning platforms to experiment with various
</I>&gt;<i> key/signing trees that may add more security, redundancy, or flexibility.
</I>&gt;<i>
</I>&gt;<i> When this first came up, someone brought up the fact that while the scheme
</I>&gt;<i> is &quot;known&quot; the initial paper as they weren't sure how to actually write a
</I>&gt;<i> proof for it. During the session, someone emailed one of the musig2 authors
</I>&gt;<i> asking for more details, and if it's safe to implement and roll out.
</I>&gt;<i> Thankfully they quickly replied and explained that the proof recursive musig
</I>&gt;<i> (pls someone correct me again here if I'm wrong) wasn't left out due to
</I>&gt;<i> impossibility, but that a proof in the existing Random Oracle Model (which
</I>&gt;<i> was used to derive a bound for the number of nonces needed) would lead to a
</I>&gt;<i> blow up in the number of nonces required. Attempting to write the proof in
</I>&gt;<i> some other model would likely lead to better results (proved w/ two nonces
</I>&gt;<i> as base musig2), but would end up being pretty complicated, so hard to read
</I>&gt;<i> and even review for correctness.
</I>&gt;<i>
</I>&gt;<i> Assuming everything checks out, then a useful mental model explained by the
</I>&gt;<i> musig2 BIP author is a sort of tree structure. Assuming I'm a signer, and we
</I>&gt;<i> assemble the other signer as a sibling leaf in a binary tree, then I just
</I>&gt;<i> need to wait for the sibling nonce/key, before I can aggregate that into
</I>&gt;<i> the final value. So if there're 3 signers, I wait for the regular public
</I>&gt;<i> nonce, but the other signers sum their respective nonces into a single
</I>&gt;<i> nonce, then send that to me. A similar operation is carried out for key
</I>&gt;<i> aggregation, with the rest of the protocol being mostly the same.
</I>&gt;<i>
</I>&gt;<i> Ultimately, even if wallets/nodes aren't ready to roll something like this
</I>&gt;<i> out today, we at least want to make sure the proposed flow is compatible
</I>&gt;<i> with Simple Taproot Channels, and ideally we'd have a toy implementation to
</I>&gt;<i> verify out understanding and show it's possible/sound. I volunteered to hack
</I>&gt;<i> up a simple recursive musig2 demo, as there doesn't seem to be any code in
</I>&gt;<i> the wild that implements it.
</I>&gt;<i>
</I>&gt;<i> ## Lightning Gossip
</I>&gt;<i>
</I>&gt;<i> # Gossip V2: Now Or Later?
</I>&gt;<i>
</I>&gt;<i> Another big topic related to Taproot was the question of how we should
</I>&gt;<i> update the gossip network: the gossip protocol today has all channels
</I>&gt;<i> validated by node, which requires that the nodes understand how to
</I>&gt;<i> reconstruct the funding output based on the set of advertised keys. The
</I>&gt;<i> protocol today assumes a segwit v0 p2wsh multi-sig is used. Assuming we had
</I>&gt;<i> everything implemented today, a node wouldn't be able to advertise its new
</I>&gt;<i> taproot channels to the rest of the public graph as they wouldn't understand
</I>&gt;<i> how to validate it.
</I>&gt;<i>
</I>&gt;<i> This presents a new opportunity: we already need to rework gossip for
</I>&gt;<i> taproot, so should we go ahead and re-design the entire thing with an eye
</I>&gt;<i> for better privacy and future extensibility?
</I>&gt;<i>
</I>&gt;<i> A proposal for the &quot;re-design the entire thing&quot; was floated in the past by
</I>&gt;<i> Rusty [6]. It does away with the strict coupling of channels to channel
</I>&gt;<i> announcements, and instead moves them to the _node_ level. Each node would
</I>&gt;<i> then advertise the set of &quot;outputs&quot; they have control of, which would then
</I>&gt;<i> be mapped to the total capacity of a node, without requiring that these
</I>&gt;<i> outputs self identify themselves on-chain as Lightning Channels. This also
</I>&gt;<i> opens up the door to different, potentially more privacy preserving
</I>&gt;<i> proofs-of-channel-ownership (something something zkp).
</I>&gt;<i>
</I>&gt;<i> On the other hand, we could just follow the path of Simple Taproot Channels
</I>&gt;<i> and map musig2+schnorr onto the existing gossip network. This is less
</I>&gt;<i> changes in total, with the main benefit being the ability to only send 1 sig
</I>&gt;<i> (aggregated musig2 sig of keys) instead of 4 individual sigs. I made a very
</I>&gt;<i> lofty proposal in this direction here [7].
</I>&gt;<i>
</I>&gt;<i> Ultimately we decided to take the &quot;just musig2 aspects&quot; from gossip v1.5
</I>&gt;<i> (not the real name), and the &quot;let's refresh all the messages w/ TLV
</I>&gt;<i> goodness&quot; from the gossip v2 proposal. This gives us a smaller package to
</I>&gt;<i> implement, and lets us potentially rejigger the messages to be more
</I>&gt;<i> extensible and remove cruft like the node color that almost nothing uses,
</I>&gt;<i> but we all validate/store.
</I>&gt;<i>
</I>&gt;<i> The follow up work in this area is a more concrete proposal that updates the
</I>&gt;<i> relevant gossip messages to be taproot aware and TLV'd and also update the
</I>&gt;<i> set of requirements w.r.t _how_ to validate the channels in the first place
</I>&gt;<i> (so given two keys verify that applying the keyagg method of musig2 lead to
</I>&gt;<i> what' in the funding output).
</I>&gt;<i>
</I>&gt;<i> Gossip v2 will likely happen &quot;eventually&quot;, but the rather large design space
</I>&gt;<i> needs to be explored a bit more so we can properly analyze exactly what
</I>&gt;<i> privacy and extensibility properties we'll get out of it.
</I>&gt;<i>
</I>&gt;<i> # Applying Mini Sketch to LN Gossip
</I>&gt;<i>
</I>&gt;<i> One issue we have today, is that other than the initial scid query mechanism
</I>&gt;<i> added to the protocol, there isn't a great way to ensure you have all the
</I>&gt;<i> latest updates your peer has. These days, many nodes pretty aggressively
</I>&gt;<i> rate limit other nodes, so you might even have trouble sending out your
</I>&gt;<i> update in the first place. A recent paper (that I haven't actually fully
</I>&gt;<i> read yet) [8] analyzes the gossip network today to work out things like:
</I>&gt;<i> exactly how long it takes things to propagate, total bandwidth usage, etc.
</I>&gt;<i>
</I>&gt;<i> Minisketch [9] (the grandchild of IBLTs ;)), is an efficient set
</I>&gt;<i> reconciliation protocol that was designed for Bitcoin p2p mempool syncing,
</I>&gt;<i> but can be applied to other protocols. An attendee has been working on
</I>&gt;<i> brushing off some older work to try to see how we could apply it to the LN
</I>&gt;<i> protocol to give nodes a more bandwidth efficient way to sync channel
</I>&gt;<i> updates, and also achieve better update propagation. This supplements some
</I>&gt;<i> existing investigative work done by Alex Meyers [10], with more concrete
</I>&gt;<i> designs w.r.t: what goes into the sketch, and the various size parameters
</I>&gt;<i> that need to be chosen.
</I>&gt;<i>
</I>&gt;<i> # Channel Jamming
</I>&gt;<i>
</I>&gt;<i> An attendee gave a talk on the various proposed solutions to channel
</I>&gt;<i> jamming, evaluating them on several axis including: punishment/monetary,
</I>&gt;<i> local vs global reputation, feasibility of mechanism design, UX
</I>&gt;<i> implications, and implementation complexity. The presenter didn't present a
</I>&gt;<i> new concrete proposal, but instead went through the various trade-offs,
</I>&gt;<i> ultimately concluding that they factor monetary penalties wherein the funds
</I>&gt;<i> are distributed across the route, rather than being provably burnt to
</I>&gt;<i> miners. However they alluded to some future upcoming work that attempts a
</I>&gt;<i> more rigorous analysis of the proposed solutions, their tradeoffs, and
</I>&gt;<i> potential ways we can parametrize solutions to be more effective (how much
</I>&gt;<i> should they pay, etc).
</I>&gt;<i>
</I>&gt;<i> For those looking to brush up on the latest state of research/mitigations in
</I>&gt;<i> this area, I recommend this blog post by Bitmex research [11].
</I>&gt;<i>
</I>&gt;<i> # Onion Messages &amp; DoS
</I>&gt;<i>
</I>&gt;<i> The topic of DoS concerns related to onion messages (in isolation, so not
</I>&gt;<i> necessarily related to things like bolt12 that take advantage of them came
</I>&gt;<i> up. During a white boarding session some argued that DoS isn't actually
</I>&gt;<i> much of an issue, as nodes can leverage &quot;back propagation congestion
</I>&gt;<i> control&quot; to inform the source (who may not actually be the sender) that
</I>&gt;<i> they'll start to drop or limit their packets, with each node doing this
</I>&gt;<i> iteratively until the actual source of the spam has been clamped. A few
</I>&gt;<i> lofty designs were thrown around, but more work needs to be done to
</I>&gt;<i> concretely specify something so it can be properly analyzed.
</I>&gt;<i>
</I>&gt;<i> On the other side of the spectrum, rather than attempt to rate limit at the
</I>&gt;<i> node level (which each node having their own policy), nodes could opt
</I>&gt;<i> instead to forward _anything_ as long as the sender pays them enough. I
</I>&gt;<i> proposed a lofty approach that combined AMP and Onion Messages earlier this
</I>&gt;<i> year [12]. At a high level I make an AMP payment, which pushes extra coins
</I>&gt;<i> to all nodes on a route, and also drops off a special identifier to them.
</I>&gt;<i> When I send an onion message I include this identifier, with each node
</I>&gt;<i> performing their own account w.r.t the amount of bandwidth an ID has
</I>&gt;<i> remaining.
</I>&gt;<i>
</I>&gt;<i> Ultimately a few implementations are pretty close to deploying their
</I>&gt;<i> implementation of onion messages, so no matter the intended use case, it
</I>&gt;<i> would be good to have code deployed along side to either rate limit or price
</I>&gt;<i> resource consumption accordingly. Otherwise, we might end up in a scenario
</I>&gt;<i> where DoS concerns were brushed aside, but end up being a huge issue later.
</I>&gt;<i>
</I>&gt;<i> # Blinded Paths, QR Codes &amp; Invoices
</I>&gt;<i>
</I>&gt;<i> Blinded paths [13] is a new-er proposal to solve the &quot;last mile&quot; privacy
</I>&gt;<i> issue when receiving payments on LN. Today invoices to unadvertised channels
</I>&gt;<i> contain a set of hop hints, which are anchored at public nodes in the graph,
</I>&gt;<i> and also leak the scid of the unadvertised channel (points on-chain to the
</I>&gt;<i> channel receiving payments). A solution for the on-chain leak, SCID channel
</I>&gt;<i> aliases [15] are in the process of being widely rolled out. Channel aliases
</I>&gt;<i> instead use a random value in the invoice, allowing receiving nodes to break
</I>&gt;<i> that on-chain link and even rotate out the value periodically. With the
</I>&gt;<i> on-chain leak addressed, it's still the case that you give away your
</I>&gt;<i> &quot;position&quot; in the network, since as a sender I know that you're connected to
</I>&gt;<i> node N with a private channel.
</I>&gt;<i>
</I>&gt;<i> Blinded paths address this node-level last mile privacy leak by replacing
</I>&gt;<i> hop hints with a new cryptographically blinded path. At a high level, the
</I>&gt;<i> receiver can construct a &quot;hop hint&quot; of length greater than 1, gather the
</I>&gt;<i> public keys of each of the nodes, then blinded them such that: the sender
</I>&gt;<i> can use them for path finding, but doesn't actually now exactly _which_
</I>&gt;<i> nodes they actually are.
</I>&gt;<i>
</I>&gt;<i> There're two type of blinded paths: those in onion messages and those used
</I>&gt;<i> for actual payments. The latter variant was only formalized earlier this
</I>&gt;<i> year, as before people were mainly interested in using them to fetch BOLT 12
</I>&gt;<i> invoice via onion messages. One issue that pops up when attempting to use
</I>&gt;<i> blinded paths for normal payments is: the size of the resulting invoice. As
</I>&gt;<i> blinded paths are actually fragments of publicly known paths, as a receiver,
</I>&gt;<i> you want to stuff as many of them into the invoice as possible, since they
</I>&gt;<i> MUST be taken in order to route towards you. Invoices are typically
</I>&gt;<i> communicated via QR codes, which have a hard limit w.r.t the amount of
</I>&gt;<i> information that can be packed in. On the other hand for invoice fetching,
</I>&gt;<i> all that matters is that a path exists, so you can get by with stuffing less
</I>&gt;<i> of then in a QR code.
</I>&gt;<i>
</I>&gt;<i> As a result, blinded paths aren't necessarily compatible with the widely
</I>&gt;<i> deployed BOLT 11 based QR codes. Instead a way to fetch invoice on demand is
</I>&gt;<i> required. Both BOLT-12 and LN-URL provide standardized ways for nodes to
</I>&gt;<i> fetch invoices, though their transport/signalling medium of choice differs.
</I>&gt;<i> Blinded routes are technically compatible with BOLT 11 invoices, but may be
</I>&gt;<i> hampered by the fact that you can only include so many routes.
</I>&gt;<i>
</I>&gt;<i> Another consideration is that unlike hop hints, blinded paths require more
</I>&gt;<i> maintain once, as since they traverse public route, policy changes like a
</I>&gt;<i> fee update may invalidate an entire set set of routes. One proposed solution
</I>&gt;<i> is that forwarding nodes should observe their older policy for a period of
</I>&gt;<i> time (so a grace period), and also that blinded paths should have an
</I>&gt;<i> explicit expiry (similar to the existing invoice expiry).
</I>&gt;<i>
</I>&gt;<i> One other implication is that the set of routes the receiver includes matters
</I>&gt;<i> more: if they don't send enough or select them poorly, the sender may never be
</I>&gt;<i> able to reach them even though a path exists in theory. More hands on
</I>&gt;<i> experience is needed so the spec authors can better guide implementations and
</I>&gt;<i> wallets w.r.t best practices.
</I>&gt;<i>
</I>&gt;<i> # Friend-of-a-friend Balance Sharing &amp; Probing
</I>&gt;<i>
</I>&gt;<i> A presentation was given on friend-of-a-friend balance sharing [16]. The
</I>&gt;<i> high level idea is that if we share _some_ information within a local
</I>&gt;<i> radius, then this gives the sender more information to choose a path that's
</I>&gt;<i> potentially more reliable. The tradeoff here ofc is that nodes will be
</I>&gt;<i> giving away more information that can potentially be used to ascertain
</I>&gt;<i> payment flows. In an attempt to minimize the amount of information shared,
</I>&gt;<i> the presenter proposed that just 2 bits of information be shared. Some
</I>&gt;<i> initial simulations showed that sharing local information actually performed
</I>&gt;<i> better than sharing global information (?). Some were puzzled w.r.t how
</I>&gt;<i> that's possible, but assuming the slides+methods are published others can
</I>&gt;<i> dig further into the model/parameter used to signal the inclusion.
</I>&gt;<i>
</I>&gt;<i> Arguably, information like this is already available via probing, so one
</I>&gt;<i> line of thinking is something like: &quot;why not just share _some_ of it&quot; that
</I>&gt;<i> may actually lead to less internal failures? This is related to a sort of
</I>&gt;<i> tension between probing as a tool to increase payment reliability and also
</I>&gt;<i> as a tool to degrade privacy in the network. On the other hand, others
</I>&gt;<i> argued that probing provides natural cover traffic, since they actually
</I>&gt;<i> _are_ payments, though they may not be intended to succeed.
</I>&gt;<i>
</I>&gt;<i> On the topic of channel probing, a sort of makeshift protocol was devised to
</I>&gt;<i> make it harder in practice, sacrificing too much on the axis of payment
</I>&gt;<i> reliability. At a high level it proposes that:
</I>&gt;<i>
</I>&gt;<i> * nodes more diligently set both their max_htlc amount, as well as the
</I>&gt;<i> max_htlc_value_in_flight amount
</I>&gt;<i>
</I>&gt;<i> * a 50ms (or select other value) timer should be used when sending out
</I>&gt;<i> commitment signatures, independent of HTLC arrival
</I>&gt;<i>
</I>&gt;<i> * nodes leverage the max_htlc value to set a false ceiling on the max in
</I>&gt;<i> flight parameter
</I>&gt;<i>
</I>&gt;<i> * for each HTLC sent/forwarded, select 2 other channels at random and
</I>&gt;<i> reduce the &quot;fake&quot; in-flight ceiling for a period of time
</I>&gt;<i>
</I>&gt;<i> Some more details still need to be worked out, but some felt that this would
</I>&gt;<i> kick start more research into this area, and also make balance mapping
</I>&gt;<i> _slightly_ more difficult. From afar, it may be the case that achieving
</I>&gt;<i> balance privacy while also achieving acceptable levels of payment
</I>&gt;<i> reliability might be at odds with each other.
</I>&gt;<i>
</I>&gt;<i> # Eltoo &amp; ANYPREVOUT
</I>&gt;<i>
</I>&gt;<i> One of the attendees is currently working on both fully implementing eltoo,
</I>&gt;<i> as well as specifying the exact channel funding+update interaction were it
</I>&gt;<i> to be rolled out align side the existing penalty based channels in the
</I>&gt;<i> protocol. As this version of eltoo is based on Taproot, we were able to
</I>&gt;<i> compare notes a bit to find the overlapping set of changes (nonce handling,
</I>&gt;<i> etc), which permits cross review of the proposals. This type of work is
</I>&gt;<i> cool, as only by fully implementing something end to end can you reaaally
</I>&gt;<i> work out all the edge cases and nuances.
</I>&gt;<i>
</I>&gt;<i> ANYPREVOUT as hasn't changed significantly as of late. An attendee shared
</I>&gt;<i> plans to create a sort of mega all-future-feasible-soft-forks fork of
</I>&gt;<i> bitcoind, that would package up various unmerged (from bitcoind's) proposal
</I>&gt;<i> soft fork packages into an easy to run+install binary/project attached to a
</I>&gt;<i> signet. The hop is that by giving developers an easy way to interact with
</I>&gt;<i> proposed soft fork proposals (vs debasing some ancient pull request), wider
</I>&gt;<i> participation in testing/implementation/review can be facilitated.
</I>&gt;<i>
</I>&gt;<i> # Trampoline Routing
</I>&gt;<i>
</I>&gt;<i> There was a presentation on Trampoline routing explaining the motivation,
</I>&gt;<i> history, and current state of the proposal. The two main cases we've
</I>&gt;<i> narrowed down on are:
</I>&gt;<i>
</I>&gt;<i> 1. A mobile user doesn't necessarily want to sync the _entire_ graph, so
</I>&gt;<i> they can use trampoline to maintain a subset and still be able to send
</I>&gt;<i> payments.
</I>&gt;<i>
</I>&gt;<i> 2. A mobile user wants to be able to instate a payment, go offline, and
</I>&gt;<i> return at a later time to learn about the final state of the payment.
</I>&gt;<i>
</I>&gt;<i> Use case #2 seems to be the most promising when combined with other
</I>&gt;<i> proposals for holding HTLCs at an origin node (call it an &quot;LSP&quot;) [13].
</I>&gt;<i> Combined together, this would allow a mobile node to send a payment, then go
</I>&gt;<i> offline, with the LSP being able to retry the payment either continuously or
</I>&gt;<i> only when it knows the receiver is online to accept the payment. This may
</I>&gt;<i> potentially dramatically improve the UX for LN on mobile, as things suddenly
</I>&gt;<i> become a lot more asynchronous: I do something go offline, and the LSP node
</I>&gt;<i> can fulfil the payment in the background, then wait for me to come online to
</I>&gt;<i> settle the final. hop.
</I>&gt;<i>
</I>&gt;<i> Trampoline can also be composed well with blinded routes (blinded route from
</I>&gt;<i> last trampoline to receiver) and also MPP (internal nodes can split
</I>&gt;<i> themselves with local information).
</I>&gt;<i>
</I>&gt;<i> One added trade-off is that since the sender doesn't know the entire route,
</I>&gt;<i> they need to sort of overshoot w.r.t fees and CTLVs. This is something
</I>&gt;<i> we've known for a while, but until Trampoline is more widely rolled out, we
</I>&gt;<i> won't have a very good feel w.r.t how much extra senders will need to
</I>&gt;<i> allocate.
</I>&gt;<i>
</I>&gt;<i> # Node Fee Optimization &amp; Fee Rate Cards
</I>&gt;<i>
</I>&gt;<i> Over the past few years, a common thread we've seen across successful
</I>&gt;<i> routing nodes is dynamic fee setting as a way to encourage/discourage
</I>&gt;<i> traffic. A routing nodes can utilize the set of fees of a channel to either
</I>&gt;<i> make it too expensive for other nodes to route through (it's already
</I>&gt;<i> depleted don't try unless you'll give be 10 mil sats, which no one would) or
</I>&gt;<i> very cheap, which'll incentivize flows in the other direction. If all nodes
</I>&gt;<i> are constantly sending out updates of this nature, then it can generate a
</I>&gt;<i> lot of traffic, and also sort of leak more balance information overtime
</I>&gt;<i> (which some nodes are already doing: using fees/max_htlc to communicate
</I>&gt;<i> available balances).
</I>&gt;<i>
</I>&gt;<i> One attendee proposed allowing nodes to express a sort of fee gradient via a
</I>&gt;<i> static curve/bucket/function, instead of dynamically communicating what the
</I>&gt;<i> latest state of the fee+liquidity distribution looks like. A possible
</I>&gt;<i> manifestation could be a series of buckets, each of which with varying fee
</I>&gt;<i> rates. If your payment consumes 50% of channel balance, then you pay this
</I>&gt;<i> rate, otherwise if it's 5% you pay this rate, etc, etc. This might allow for
</I>&gt;<i> nodes to capture the same dynamics as they do with more dynamic fee updates,
</I>&gt;<i> but in a way that leaks less information and also consumes less gossip
</I>&gt;<i> bandwidth.
</I>&gt;<i>
</I>&gt;<i> # The Return of Splicing
</I>&gt;<i>
</I>&gt;<i> Splicing is one of those things that was discussed a long time ago, but was
</I>&gt;<i> never really fully implemented and rolled out. A few attendees have started
</I>&gt;<i> to take a closer look at the problem, building off of the interactive-tx
</I>&gt;<i> scheme that the dual-funding protocol extension uses. The main intricacy
</I>&gt;<i> discussed was if concurrent splices should be allowed or not, and if so, how
</I>&gt;<i> we would handle the various edge cases. As an example, if I propose a splice
</I>&gt;<i> to add more funds via my input, but that turns out to already be spent, then
</I>&gt;<i> the splicing transaction we created is invalid and can never be confirmed.
</I>&gt;<i> However if we allow _another_ splice to take place, and another one, and
</I>&gt;<i> another one, then ideally _one_ of them will confirm and serve as the new
</I>&gt;<i> anchor for the channel.
</I>&gt;<i>
</I>&gt;<i> In a world of concurrent splices, the question of &quot;what is my Lightning
</I>&gt;<i> balance&quot; becomes even more murky. Wallet and implementations will likely
</I>&gt;<i> want to show the most pessimistic value, while also ensuring that the user
</I>&gt;<i> is able to effectively account for where all their funds and what they can
</I>&gt;<i> spend on/off chain.
</I>&gt;<i>
</I>&gt;<i> # LN-URL + BOLT 12
</I>&gt;<i>
</I>&gt;<i> LN-URL and BOLT 12 are both standardized ways that answer the question of:
</I>&gt;<i> how can I fetch an invoice from Bob? LN-URL differs from BOLT 12 in that it
</I>&gt;<i> uses the existing BOLT 11 invoice format, and uses an HTTP based protocol
</I>&gt;<i> for the negotiation process. BOLT 12 on the other hand is a suite of
</I>&gt;<i> protocol additions that includes (amongst other things) a new invoice format
</I>&gt;<i> (yay TLV!) and also a way to use onion messages to fetch an invoice _via_
</I>&gt;<i> the network.
</I>&gt;<i>
</I>&gt;<i> Assuming blinded paths is widely rolled out, then the question of how
</I>&gt;<i> invoices are obtained becomes more important as blinded paths means that you
</I>&gt;<i> can't fit much in the traditional QR encoding. As a result, fetching
</I>&gt;<i> invoices on demand may become a more common place flow, with all its
</I>&gt;<i> trade-offs. There was a group discussion on how we could sort of unifying
</I>&gt;<i> everything either by allowing BOLT 12 to be used over LN-URL or the other
</I>&gt;<i> way around.
</I>&gt;<i>
</I>&gt;<i> One proposal was to add a new query parameter to the normal LN-URL QR code
</I>&gt;<i> contents. This would mean that when a wallet goes to scan an LN-URL QR code,
</I>&gt;<i> if they know of the extra param, and what BOLT 12, they can just use the
</I>&gt;<i> enclosed offer to fetch the invoice.
</I>&gt;<i>
</I>&gt;<i> An alternative proposal was to instead extract the BOLT 12 _invoice_ format
</I>&gt;<i> from the greater BOLT 12 &quot;Offers&quot; proposal. Assuming blinded paths is only
</I>&gt;<i> specified w.r.t BOLT 12 _invoices_, then this would mean an LN-URL extension
</I>&gt;<i> could be rolled out that allowed returning BOLT 12 invoice rather than BOLT
</I>&gt;<i> 11 invoices. This would allow the ecosystem to slowly transition to a shared
</I>&gt;<i> invoice format, even if there may be fundamental disagreements w.r.t _how_
</I>&gt;<i> the invoices should be fetched in the first place.
</I>&gt;<i>
</I>&gt;<i> It's worth noting that both of these proposals can be combined:
</I>&gt;<i>
</I>&gt;<i> * If a wallet knows how to BOLT 12 Offers, they can take the enclosed
</I>&gt;<i> offer and run w/ it.
</I>&gt;<i>
</I>&gt;<i> * If they don't know about Offers, but can send w/ the BOLT _invoice_
</I>&gt;<i> format, then they can fetch that and complete the payment.
</I>&gt;<i>
</I>&gt;<i> This might be a nice middle ground as it would tend all
</I>&gt;<i> wallets/implementations to being able to decode and send w/ a BOLT 12
</I>&gt;<i> _invoice_, and leave the question of _how_ it should be fetched up to the
</I>&gt;<i> application/wallet/service. In the end, if paths never quite intersect, then
</I>&gt;<i> it's still possible to add route blinding to BOLT 11, with LN-URL sticking
</I>&gt;<i> with that invoice format to take advantage of the new privacy enhancements
</I>&gt;<i>
</I>&gt;<i> [1]: <A HREF="../2021-November/003336.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-November/003336.html</A>
</I>&gt;<i> [2]: <A HREF="../2021-October/003278.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003278.html</A>
</I>&gt;<i> [3]: <A HREF="https://github.com/lightning/bolts/pull/995">https://github.com/lightning/bolts/pull/995</A>
</I>&gt;<i> [4]: <A HREF="https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki">https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki</A>
</I>&gt;<i> [5]: <A HREF="https://datatracker.ietf.org/doc/html/rfc6979">https://datatracker.ietf.org/doc/html/rfc6979</A>
</I>&gt;<i> [6]: <A HREF="../2022-February/003470.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-February/003470.html</A>
</I>&gt;<i> [7]: <A HREF="../2022-March/003526.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-March/003526.html</A>
</I>&gt;<i> [8]: <A HREF="https://arxiv.org/abs/2205.12737">https://arxiv.org/abs/2205.12737</A>
</I>&gt;<i> [9]: <A HREF="https://bitcoinops.org/en/topics/minisketch/">https://bitcoinops.org/en/topics/minisketch/</A>
</I>&gt;<i> [10]: <A HREF="../2022-April/003551.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-April/003551.html</A>
</I>&gt;<i> [11]: <A HREF="https://blog.bitmex.com/preventing-channel-jamming/">https://blog.bitmex.com/preventing-channel-jamming/</A>
</I>&gt;<i> [12]: <A HREF="../2022-February/003498.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-February/003498.html</A>
</I>&gt;<i> [13]: <A HREF="https://github.com/lightning/bolts/pull/765">https://github.com/lightning/bolts/pull/765</A>
</I>&gt;<i> [14]: <A HREF="../2021-October/003307.html">https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003307.html</A>
</I>&gt;<i> [15]: <A HREF="https://github.com/lightning/bolts/pull/910">https://github.com/lightning/bolts/pull/910</A>
</I>&gt;<i> [16]: <A HREF="https://github.com/lightning/bolts/pull/780">https://github.com/lightning/bolts/pull/780</A>
</I>&gt;<i>
</I>&gt;<i> -- Laolu
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220621/89814a22/attachment-0001.html">http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220621/89814a22/attachment-0001.html</A>&gt;
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003608.html">[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary
</A></li>
	<LI>Next message: <A HREF="003614.html">[Lightning-dev] LN Summit 2022 Notes &amp; Summary/Commentary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3615">[ date ]</a>
              <a href="thread.html#3615">[ thread ]</a>
              <a href="subject.html#3615">[ subject ]</a>
              <a href="author.html#3615">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>

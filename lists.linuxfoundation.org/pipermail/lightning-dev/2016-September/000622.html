<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lightning-dev] [BOLT Draft] Onion Routing Spec
   </TITLE>
   <LINK REL="Index" HREF="https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-September/index.html" >
   <LINK REL="made" HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20%5BBOLT%20Draft%5D%20Onion%20Routing%20Spec&In-Reply-To=%3C8760piglkv.fsf%40rustcorp.com.au%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000609.html">
   <LINK REL="Next"  HREF="000603.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lightning-dev] [BOLT Draft] Onion Routing Spec</H1>
    <B>Rusty Russell</B> 
    <A HREF="mailto:lightning-dev%40lists.linuxfoundation.org?Subject=Re:%20Re%3A%20%5BLightning-dev%5D%20%5BBOLT%20Draft%5D%20Onion%20Routing%20Spec&In-Reply-To=%3C8760piglkv.fsf%40rustcorp.com.au%3E"
       TITLE="[Lightning-dev] [BOLT Draft] Onion Routing Spec">rusty at rustcorp.com.au
       </A><BR>
    <I>Tue Sep 27 01:47:44 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="000609.html">[Lightning-dev] [BOLT Draft] Onion Routing Spec
</A></li>
        <LI>Next message: <A HREF="000603.html">[Lightning-dev] [BOLT Draft] Onion Routing Spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#622">[ date ]</a>
              <a href="thread.html#622">[ thread ]</a>
              <a href="subject.html#622">[ subject ]</a>
              <a href="author.html#622">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>(Sorry for delay: travel plus laptop issues...)

Olaoluwa Osuntokun &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">laolu32 at gmail.com</A>&gt; writes:
&gt;<i> Rusty Russell &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">rusty at rustcorp.com.au</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Each node ID is 33 bytes (pubkey) each channel is 6 bytes (blocknum +
</I>&gt;<i> txnum).
</I>&gt;<i>
</I>&gt;<i> Using blocknum+txnum to identify a channel doesn't account for the
</I>&gt;<i> possibility of a single transaction which opens multiple channels
</I>&gt;<i> concurrently. A possible use-case for such a transaction are coin-joined
</I>&gt;<i> channel openings which obfuscate the relationships being creating with a
</I>&gt;<i> channel opening. You'd need to tack on an extra byte (maybe two) to also
</I>&gt;<i> encode the output index of the channel within the transaction.
</I>
Great point.  We should absolutely support this.

&gt;<i> Additionally, identifying channels based solely from
</I>&gt;<i> blockheight+offsets conjures up some re-org safety concerns. It's also
</I>&gt;<i> a bit less &quot;verifiable&quot; than referring via the full outpoint.
</I>
A little, but the compactness is worth it.  If you're an SPV node you'll
need a proof, and if you're not you'll know if it's not in the main
chain.

&gt;&gt;<i> The proofs are larger: to prove which IDs owns a channel, each one needs a
</I>&gt;&gt;<i> merkle proof (12 x 32 bytes) plus the funding tx (227 bytes, we can skip
</I>&gt;&gt;<i> some though), the two pubkeys (66 bytes), and a signature of the ID using
</I>&gt;&gt;<i> those pubkeys (128 bytes, schnorr would be 64?).
</I>&gt;<i>
</I>&gt;<i> Are those two pub keys the multi-sig pub keys, or the identity pub keys? In
</I>&gt;<i> either case, only requiring two pub keys to attest-to/authenticate the state
</I>&gt;<i> of a channel is insufficient. With only two signatures, then nodes can
</I>&gt;<i> advertise the same channel several times creating a non-canonical graphs
</I>&gt;<i> resulting in differing network views. If we'd like to eliminate such a
</I>&gt;<i> possibility, then we also need to cryptographically bind the two identities
</I>&gt;<i> to the proof.
</I>
Yeah, it's not sufficient to get the multisig keys to sign the ID.

&gt;<i> Using a schnorr multi-signature generated by the four pubkeys
</I>&gt;<i> would remedy this. Validators can use pubkey recovery to extract the &quot;group
</I>&gt;<i> pubkey&quot; from the single signature, ensure it's the result of point addition
</I>&gt;<i> of the four public keys, check the channel isn't closed, then verify the
</I>&gt;<i> signature over the advertisement as normal.
</I>
I think this only works if the on-chain keys are Schnorr, right?
Until then, we'd need the ID to sign the pubkeys (or anything which
uniquely identified the channel tx).

&gt;<i> Christian Decker &lt;<A HREF="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">decker.christian at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> I forgot that we have two potential key-rotations:
</I>&gt;&gt;<i> - Rotating the key used in transactions that hit the Bitcoin network
</I>&gt;<i>
</I>&gt;<i> If you mean the key included within the 2-of-2 multi-sig, I assume all
</I>&gt;<i> implementations will be using a fresh key with each channel either way, so
</I>&gt;<i> we don't need any explicit rotations here?
</I>&gt;<i>
</I>&gt;<i> I've only been thinking of rotations for the onion pubkeys used for the DH
</I>&gt;<i> shared secret derivation for the onion packets. Identity keys could also
</I>&gt;<i> possibly either be rotated/revoked, or delegated with some sort of
</I>&gt;<i> &quot;certificate&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i> Another case we could consider is having passive rotations: when an
</I>&gt;&gt;<i> endpoint announces a channel's existence it also sends its rotation
</I>&gt;&gt;<i> interval along.
</I>&gt;<i>
</I>&gt;<i> IMO a passive rotation scheme is superior due to the bandwidth savings of
</I>&gt;<i> pushing the onion key rotations to the edges themselves. As you said an
</I>&gt;<i> active rotation might be used in the emergency case of a forced key rotation
</I>&gt;<i> due to key compromise.
</I>
As you state below (and as confirmed by Adam Back and others I asked at
Blockstream), there is no passive scheme for forward secrecy though
unless we want pairing crypto and magic.  So might as well not rotate
keys in that case.

&gt;<i> Earlier in this email chain I suggested a scheme to regain forward secrecy
</I>&gt;<i> in the case of such a private key leak by requiring nodes to do some upfront
</I>&gt;<i> pre-computation involving an intermediate derivation point. This would still
</I>&gt;<i> allow passive rotation by the edges. However, in practice those
</I>&gt;<i> pre-generated would likely be stored in the same location? So that kinda
</I>&gt;<i> puts us back at the original exploit scenario.
</I>&gt;<i>
</I>&gt;<i> If we were to involve some pairing crypto (IBE style), we would use say
</I>&gt;<i> block hashes to allow nodes to passively derive keys the &quot;source&quot; node is
</I>&gt;<i> able to generate the corresponding private key to...
</I>&gt;<i>
</I>&gt;<i> IMO we need to more clearly state our security model/assumptions here to
</I>&gt;<i> reason about the attack scenarios we'll try to guard against.
</I>
Indeed.  Let me try to enumerate the different secrets we need to
protect, and you tell me what I missed?

0 - Wallet privkey(s)
  * Must be online for channel creation.
  * Compromise means all not-in-channel funds can be stolen.

1 - Commit signing bitcoin privkey (per peer)
  * Must be online for channel creation, change and close (ie. always).
  * Compromise means we can collaborate with peer to steal funds in that
    channel. (eg. sign a revoked transaction and give all funds to peer,
    or mutually sign a tx spending the funds to anywhere the attacker wants).

2 - Identity privkey
  * Must be online for channel publishing, fee changes.
  * Compromise means we can advertise new rates (or channel
    unavailability), cutting node off lightning network.

3 - Onion privkey
  * Must be online for routing (ie. always)
  * Compromise means we can decode incoming HTLC offers, maybe send fail failure
    messages.

4 - Low-level comms symmetric key (per peer)
  * Must be online always.
  * Compromise means we can decode all messages to peer, and break
    connections with them (we can't create new HTLCs or change bitcoin
    fees without the commit-signing privkey though).

5 - H-preimage (per invoice)
  * Must be online when creating or accepting payment for invoice
    (always, unless we're routing-only).
  * Compromise means we can lose associated incoming amount.

The simplest scheme is that the first four keys are the same.  That's
horrible for node privacy, since you can see even non-lightning funds.
So let's assume the wallet key is separate.

Separating commit keys from identity key allows nodes to post-hoc
announce channels (by associating them with the public identity) and
also means we can segregate peer privkeys (eg. one process per peer)
which is slightly nicer from a security POV.

Separating onion privkey allows rotation; only a win if we get forward
secrecy (not a win for this node, as much as for the network as a
whole).

The comms symmetric key should be rotated with forward secrecy as
well, for similar reasons.

(We *could* derive all the secrets from a single master secret, but
that's an implementation issue with its own tradeoffs...).

Thoughts?
Rusty.
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000609.html">[Lightning-dev] [BOLT Draft] Onion Routing Spec
</A></li>
	<LI>Next message: <A HREF="000603.html">[Lightning-dev] [BOLT Draft] Onion Routing Spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#622">[ date ]</a>
              <a href="thread.html#622">[ thread ]</a>
              <a href="subject.html#622">[ subject ]</a>
              <a href="author.html#622">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev">More information about the Lightning-dev
mailing list</a><br>
</body></html>
